<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DryIoc</name>
    </assembly>
    <members>
        <member name="T:DryIoc.Container">
            <summary>IoC Container. Documentation is available at https://bitbucket.org/dadhi/dryioc. </summary>
        </member>
        <member name="M:DryIoc.Container.#ctor">
            <summary>Creates new container with default rules <see cref="F:DryIoc.Rules.Default"/>.</summary>
        </member>
        <member name="M:DryIoc.Container.#ctor(DryIoc.Rules,DryIoc.IScopeContext)">
            <summary>Creates new container, optionally providing <see cref="P:DryIoc.Container.Rules"/> to modify default container behavior.</summary>
            <param name="rules">(optional) Rules to modify container default resolution behavior.
            If not specified, then <see cref="F:DryIoc.Rules.Default"/> will be used.</param>
            <param name="scopeContext">(optional) Scope context to use for <see cref="F:DryIoc.Reuse.InCurrentScope"/>, default is <see cref="T:DryIoc.ThreadScopeContext"/>.</param>
        </member>
        <member name="M:DryIoc.Container.#ctor(System.Func{DryIoc.Rules,DryIoc.Rules},DryIoc.IScopeContext)">
            <summary>Creates new container with configured rules.</summary>
            <param name="configure">Delegate gets <see cref="F:DryIoc.Rules.Default"/> as input and may return configured rules.</param>
            <param name="scopeContext">(optional) Scope context to use for <see cref="F:DryIoc.Reuse.InCurrentScope"/>, default is <see cref="T:DryIoc.ThreadScopeContext"/>.</param>
        </member>
        <member name="M:DryIoc.Container.ToString">
            <summary>Outputs scope info for open scope.</summary> <returns>Info about scoped container</returns>
        </member>
        <member name="M:DryIoc.Container.With(System.Func{DryIoc.Rules,DryIoc.Rules},DryIoc.IScopeContext)">
            <summary>Shares all of container state except Cache and specifies new rules.</summary>
            <param name="configure">(optional) Configure rules, if not specified then uses Rules from current container.</param>
            <param name="scopeContext">(optional) New scope context, if not specified then uses context from current container.</param>
            <returns>New container.</returns>
        </member>
        <member name="M:DryIoc.Container.WithNoMoreRegistrationAllowed(System.Boolean)">
            <summary>Produces new container which prevents any further registrations.</summary>
            <param name="ignoreInsteadOfThrow">(optional) Controls what to do with the next registration: ignore or throw exception.
            Throws exception by default.</param>
            <returns>New container preserving all current container state but disallowing registrations.</returns>
        </member>
        <member name="M:DryIoc.Container.WithoutCache">
            <summary>Returns new container with all expression, delegate, items cache removed/reset.
            It will preserve resolved services in Singleton/Current scope.</summary>
            <returns>New container with empty cache.</returns>
        </member>
        <member name="M:DryIoc.Container.WithoutSingletonsAndCache">
            <summary>Creates new container with state shared with original except singletons and cache.
            Dropping cache is required because singletons are cached in resolution state.</summary>
            <returns>New container with empty Singleton Scope.</returns>
        </member>
        <member name="M:DryIoc.Container.WithRegistrationsCopy(System.Boolean)">
            <summary>Shares all parts with original container But copies registration, so the new registration
            won't be visible in original. Registrations include decorators and wrappers as well.</summary>
            <param name="preserveCache">(optional) If set preserves cache if you know what to do.</param>
            <returns>New container with copy of all registrations.</returns>
        </member>
        <member name="P:DryIoc.Container.ScopeContext">
            <summary>Returns ambient scope context associated with container.</summary>
        </member>
        <member name="M:DryIoc.Container.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})">
            <summary>Creates new container with new opened scope, with shared registrations, singletons and resolutions cache.
            If container uses ambient scope context, then this method sets new opened scope as current scope in the context.
            In case of previous open scope, new open scope references old one as a parent.
            </summary>
            <param name="name">(optional) Name for opened scope to allow reuse to identify the scope.</param>
            <param name="configure">(optional) Configure rules, if not specified then uses Rules from current container.</param>
            <returns>New container with different current scope.</returns>
            <example><code lang="cs"><![CDATA[
            using (var scoped = container.OpenScope())
            {
                var handler = scoped.Resolve<IHandler>();
                handler.Handle(data);
            }
            ]]></code></example>
        </member>
        <member name="F:DryIoc.Container.NonAmbientRootScopeName">
            <summary>The default name of root scope without ambient context.</summary>
        </member>
        <member name="M:DryIoc.Container.CreateFacade">
            <summary>Creates container (facade) that fallbacks to this container for unresolved services.
            Facade is the new empty container, with the same rules and scope context as current container.
            It could be used for instance to create Test facade over original container with replacing some services with test ones.</summary>
            <remarks>Singletons from container are not reused by facade -
            when you resolve singleton directly from parent and then ask for it from child, it will return another object.
            To achieve that you may use <see cref="M:DryIoc.IContainer.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})"/> with <see cref="F:DryIoc.Reuse.InCurrentScope"/>.</remarks>
            <returns>New facade container.</returns>
        </member>
        <member name="M:DryIoc.Container.ClearCache(System.Type,System.Nullable{DryIoc.FactoryType},System.Object)">
            <summary>Clears cache for specified service(s).
            But does not clear instances of already resolved/created singletons and scoped services!</summary>
            <param name="serviceType">Target service type.</param>
            <param name="factoryType">(optional) If not specified, clears cache for all <see cref="T:DryIoc.FactoryType"/>.</param>
            <param name="serviceKey">(optional) If omitted, the cache will be cleared for all registrations of <paramref name="serviceType"/>.</param>
            <returns>True if target service was found, false - otherwise.</returns>
        </member>
        <member name="M:DryIoc.Container.Dispose">
            <summary>Dispose either open scope, or container with singletons, if no scope opened.</summary>
        </member>
        <member name="P:DryIoc.Container.SingletonScope">
            <summary>Scope containing container singletons.</summary>
        </member>
        <member name="F:DryIoc.Container.StateParamExpr">
            <summary>State parameter expression in FactoryDelegate.</summary>
        </member>
        <member name="F:DryIoc.Container.ResolverContextParamExpr">
            <summary>Resolver context parameter expression in FactoryDelegate.</summary>
        </member>
        <member name="F:DryIoc.Container.ResolverExpr">
            <summary>Resolver parameter expression in FactoryDelegate.</summary>
        </member>
        <member name="F:DryIoc.Container.RootResolverExpr">
            <summary>Resolver parameter expression in FactoryDelegate.</summary>
        </member>
        <member name="M:DryIoc.Container.GetResolverExpr(DryIoc.Request)">
            <summary>Returns <see cref="F:DryIoc.Container.ResolverExpr"/> or <see cref="F:DryIoc.Container.RootResolverExpr"/> based on request.</summary>
        </member>
        <member name="F:DryIoc.Container.SingletonScopeExpr">
            <summary>Resolver parameter expression in FactoryDelegate.</summary>
        </member>
        <member name="F:DryIoc.Container.ScopesExpr">
            <summary>Access to scopes in FactoryDelegate.</summary>
        </member>
        <member name="F:DryIoc.Container.RootScopesExpr">
            <summary>Resolver parameter expression in FactoryDelegate.</summary>
        </member>
        <member name="M:DryIoc.Container.GetScopesExpr(DryIoc.Request)">
            <summary>Returns <see cref="F:DryIoc.Container.ScopesExpr"/> or <see cref="F:DryIoc.Container.RootResolverExpr"/> based on request.</summary>
        </member>
        <member name="F:DryIoc.Container.ResolutionScopeParamExpr">
            <summary>Resolution scope parameter expression in FactoryDelegate.</summary>
        </member>
        <member name="M:DryIoc.Container.WrapInFactoryExpression(System.Linq.Expressions.Expression)">
            <summary>Wraps service creation expression (body) into <see cref="T:DryIoc.FactoryDelegate"/> and returns result lambda expression.</summary>
            <param name="expression">Service expression (body) to wrap.</param> <returns>Created lambda expression.</returns>
        </member>
        <member name="M:DryIoc.Container.CompileToDelegate(System.Linq.Expressions.Expression)">
            <summary>First wraps the input service expression into lambda expression and
            then compiles lambda expression to actual <see cref="T:DryIoc.FactoryDelegate"/> used for service resolution.</summary>
            <param name="expression">Service creation expression.</param>
            <returns>Compiled factory delegate to use for service resolution.</returns>
        </member>
        <member name="M:DryIoc.Container.OptimizeExpression(System.Linq.Expressions.Expression)">
            <summary>Strips the unnecessary or adds the necessary cast to expression return result.</summary>
            <param name="expression">Expression to process.</param> <returns>Processed expression.</returns>
        </member>
        <member name="M:DryIoc.Container.GetServiceRegistrations">
            <summary>Returns all registered service factories with their Type and optional Key.</summary>
            <returns>Existing registrations.</returns>
            <remarks>Decorator and Wrapper types are not included.</remarks>
        </member>
        <member name="M:DryIoc.Container.Register(DryIoc.Factory,System.Type,System.Object,DryIoc.IfAlreadyRegistered,System.Boolean)">
            <summary>Stores factory into container using <paramref name="serviceType"/> and <paramref name="serviceKey"/> as key
            for later lookup.</summary>
            <param name="factory">Any subtypes of <see cref="T:DryIoc.Factory"/>.</param>
            <param name="serviceType">Type of service to resolve later.</param>
            <param name="serviceKey">(optional) Service key of any type with <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>
            implemented.</param>
            <param name="ifAlreadyRegistered">(optional) Says how to handle existing registration with the same
            <paramref name="serviceType"/> and <paramref name="serviceKey"/>.</param>
            <param name="isStaticallyChecked">Confirms that service and implementation types are statically checked by compiler.</param>
            <returns>True if factory was added to registry, false otherwise.
            False may be in case of <see cref="F:DryIoc.IfAlreadyRegistered.Keep"/> setting and already existing factory.</returns>
        </member>
        <member name="M:DryIoc.Container.IsRegistered(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Returns true if there is registered factory with the service type and key.
            To check if only default factory is registered specify <see cref="F:DryIoc.DefaultKey.Value"/> as <paramref name="serviceKey"/>.
            Otherwise, if no <paramref name="serviceKey"/> specified then True will returned for any registered factories, even keyed.
            Additionally you can specify <paramref name="condition"/> to be applied to registered factories.</summary>
            <param name="serviceType">Service type to look for.</param>
            <param name="serviceKey">Service key to look for.</param>
            <param name="factoryType">Expected registered factory type.</param>
            <param name="condition">Expected factory condition.</param>
            <returns>True if factory is registered, false if not.</returns>
        </member>
        <member name="M:DryIoc.Container.Unregister(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Removes specified factory from registry.
            Factory is removed only from registry, if there is relevant cache, it will be kept.
            Use <see cref="M:DryIoc.Container.WithoutCache"/> to remove all the cache.</summary>
            <param name="serviceType">Service type to look for.</param>
            <param name="serviceKey">Service key to look for.</param>
            <param name="factoryType">Expected factory type.</param>
            <param name="condition">Expected factory condition.</param>
        </member>
        <member name="M:DryIoc.Container.DryIoc#IScopeAccess#GetCurrentNamedScope(System.Object,System.Boolean)">
            <summary>Gets current scope matching the <paramref name="name"/>.
            If name is null then current scope is returned, or if there is no current scope then exception thrown.</summary>
            <param name="name">May be null</param> <param name="throwIfNotFound">Says to throw if no scope found.</param>
            <returns>Found scope or throws exception.</returns>
            <exception cref="T:DryIoc.ContainerException"> with code <see cref="F:DryIoc.Error.NoMatchedScopeFound"/>.</exception>
        </member>
        <member name="M:DryIoc.Container.DryIoc#IScopeAccess#GetOrCreateResolutionScope(DryIoc.IScope@,System.Type,System.Object)">
            <summary>Check if scope is not null, then just returns it, otherwise will create and return it.</summary>
            <param name="scope">May be null scope.</param>
            <param name="serviceType">Marking scope with resolved service type.</param>
            <param name="serviceKey">Marking scope with resolved service key.</param>
            <returns>Input <paramref name="scope"/> ensuring it is not null.</returns>
        </member>
        <member name="M:DryIoc.Container.GetOrNewResolutionScope(DryIoc.IScope,System.Type,System.Object)">
            <summary>Check if scope is not null, then just returns it, otherwise will create and return it.</summary>
            <param name="scope">May be null scope.</param>
            <param name="serviceType">Marking scope with resolved service type.</param>
            <param name="serviceKey">Marking scope with resolved service key.</param>
            <returns>Input <paramref name="scope"/> ensuring it is not null.</returns>
        </member>
        <member name="M:DryIoc.Container.DryIoc#IScopeAccess#GetMatchingResolutionScope(DryIoc.IScope,System.Type,System.Object,System.Boolean,System.Boolean)">
            <summary>If both <paramref name="assignableFromServiceType"/> and <paramref name="serviceKey"/> are null,
            then returns input <paramref name="scope"/>.
            Otherwise searches scope hierarchy to find first scope with: Type assignable <paramref name="assignableFromServiceType"/> and
            Key equal to <paramref name="serviceKey"/>.</summary>
            <param name="scope">Scope to start matching with Type and Key specified.</param>
            <param name="assignableFromServiceType">Type to match.</param> <param name="serviceKey">Key to match.</param>
            <param name="outermost">If true - commands to look for outermost match instead of nearest.</param>
            <param name="throwIfNotFound">Says to throw if no scope found.</param>
            <returns>Matching scope or throws <see cref="T:DryIoc.ContainerException"/>.</returns>
        </member>
        <member name="P:DryIoc.Container.Rules">
            <summary>The rules object defines policies per container for registration and resolution.</summary>
        </member>
        <member name="P:DryIoc.Container.IsDisposed">
            <summary>Indicates that container is disposed.</summary>
        </member>
        <member name="P:DryIoc.Container.DryIoc#IContainer#EmptyRequest">
            <summary>Obsolete: replaced with <see cref="M:DryIoc.Request.Create(DryIoc.IContainer,System.Type,System.Object,DryIoc.IfUnresolved,System.Type,DryIoc.IScope,DryIoc.RequestInfo)"/>/.</summary>
        </member>
        <member name="P:DryIoc.Container.DryIoc#IContainer#ContainerWeakRef">
            <summary>Self weak reference, with readable message when container is GCed/Disposed.</summary>
        </member>
        <member name="M:DryIoc.Container.InjectPropertiesAndFields(System.Object,DryIoc.PropertiesAndFieldsSelector)">
            <summary>For given instance resolves and sets properties and fields.</summary>
            <param name="instance">Service instance with properties to resolve and initialize.</param>
            <param name="propertiesAndFields">(optional) Function to select properties and fields, overrides all other rules if specified.
            If not specified then method will use container <see cref="P:DryIoc.Rules.PropertiesAndFields"/>,
            or if not specified method fallbacks to <see cref="F:DryIoc.PropertiesAndFields.Auto"/>.</param>
            <returns>Instance with assigned properties and fields.</returns>
            <remarks>Different Rules could be combined together using <see cref="M:DryIoc.PropertiesAndFields.OverrideWith(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)"/> method.</remarks>
        </member>
        <member name="M:DryIoc.Container.CacheFactoryExpression(System.Int32,System.Linq.Expressions.Expression)">
            <summary>Adds factory expression to cache identified by factory ID (<see cref="P:DryIoc.Factory.FactoryID"/>).</summary>
            <param name="factoryID">Key in cache.</param>
            <param name="factoryExpression">Value to cache.</param>
        </member>
        <member name="M:DryIoc.Container.GetCachedFactoryExpressionOrDefault(System.Int32)">
            <summary>Searches and returns cached factory expression, or null if not found.</summary>
            <param name="factoryID">Factory ID to lookup by.</param> <returns>Found expression or null.</returns>
        </member>
        <member name="P:DryIoc.Container.ResolutionStateCache">
            <summary>State item objects which may include: singleton instances for fast access, reuses, reuse wrappers, factory delegates, etc..</summary>
        </member>
        <member name="M:DryIoc.Container.GetOrAddStateItemExpression(System.Object,System.Type,System.Boolean)">
            <summary>Converts known items into custom expression or wraps in <see cref="T:System.Linq.Expressions.ConstantExpression"/>.</summary>
            <param name="item">Item to convert.</param>
            <param name="itemType">(optional) Type of item, otherwise item <see cref="M:System.Object.GetType"/>.</param>
            <param name="throwIfStateRequired">(optional) Throws for non-primitive and not-recognized items,
            identifying that result expression require run-time state. For compiled expression it means closure in lambda delegate.</param>
            <returns>Returns constant or state access expression for added items.</returns>
        </member>
        <member name="M:DryIoc.Container.GetOrAddStateItem(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.UsedInstanceFactory.GetDelegateOrDefault(DryIoc.Request)">
            <summary>Called from Resolve method</summary>
        </member>
        <member name="M:DryIoc.Container.UsedInstanceFactory.GetExpressionOrDefault(DryIoc.Request)">
            <summary>Called for Injection as dependency.</summary>
        </member>
        <member name="T:DryIoc.ContainerTools">
            <summary>Container extended features.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.InjectPropertiesAndFields``1(DryIoc.IContainer,``0,DryIoc.PropertiesAndFieldsSelector)">
            <summary>For given instance resolves and sets properties and fields.
            It respects <see cref="P:DryIoc.Rules.PropertiesAndFields"/> rules set per container,
            or if rules are not set it uses <see cref="F:DryIoc.PropertiesAndFields.Auto"/>,
            or you can specify your own rules with <paramref name="propertiesAndFields"/> parameter.</summary>
            <typeparam name="TService">Input and returned instance type.</typeparam>Service (wrapped)
            <param name="container">Usually a container instance, cause <see cref="T:DryIoc.Container"/> implements <see cref="T:DryIoc.IResolver"/></param>
            <param name="instance">Service instance with properties to resolve and initialize.</param>
            <param name="propertiesAndFields">(optional) Function to select properties and fields, overrides all other rules if specified.</param>
            <returns>Input instance with resolved dependencies, to enable fluent method composition.</returns>
            <remarks>Different Rules could be combined together using <see cref="M:DryIoc.PropertiesAndFields.OverrideWith(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)"/> method.</remarks>
        </member>
        <member name="M:DryIoc.ContainerTools.New(DryIoc.IContainer,System.Type,DryIoc.Made)">
            <summary>Creates service using container for injecting parameters without registering anything in <paramref name="container"/>.</summary>
            <param name="container">Container to use for type creation and injecting its dependencies.</param>
            <param name="concreteType">Type to instantiate. Wrappers (Func, Lazy, etc.) is also supported.</param>
            <param name="made">(optional) Injection rules to select constructor/factory method, inject parameters, properties and fields.</param>
            <returns>Object instantiated by constructor or object returned by factory method.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.New``1(DryIoc.IContainer,DryIoc.Made)">
            <summary>Creates service using container for injecting parameters without registering anything in <paramref name="container"/>.</summary>
            <typeparam name="T">Type to instantiate.</typeparam>
            <param name="container">Container to use for type creation and injecting its dependencies.</param>
            <param name="made">(optional) Injection rules to select constructor/factory method, inject parameters, properties and fields.</param>
            <returns>Object instantiated by constructor or object returned by factory method.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.New``1(DryIoc.IContainer,DryIoc.Made.TypedMade{``0})">
            <summary>Creates service given strongly-typed creation expression.
            Can be used to invoke arbitrary method returning some value with injecting its parameters from container.</summary>
            <typeparam name="T">Method or constructor result type.</typeparam>
            <param name="container">Container to use for injecting dependencies.</param>
            <param name="made">Creation expression.</param>
            <returns>Created result.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.RegisterMapping(DryIoc.IContainer,System.Type,System.Type,System.Object,System.Object)">
            <summary>Registers new service type with factory for registered service type.
            Throw if no such registered service type in container.</summary>
            <param name="container">Container</param> <param name="serviceType">New service type.</param>
            <param name="registeredServiceType">Existing registered service type.</param>
            <param name="serviceKey">(optional)</param> <param name="registeredServiceKey">(optional)</param>
            <remarks>Does nothing if registration is already exists.</remarks>
        </member>
        <member name="M:DryIoc.ContainerTools.RegisterMapping``2(DryIoc.IContainer,System.Object,System.Object)">
            <summary>Registers new service type with factory for registered service type.
            Throw if no such registered service type in container.</summary>
            <param name="container">Container</param>
            <typeparam name="TService">New service type.</typeparam>
            <typeparam name="TRegisteredService">Existing registered service type.</typeparam>
            <param name="serviceKey">(optional)</param> <param name="registeredServiceKey">(optional)</param>
            <remarks>Does nothing if registration is already exists.</remarks>
        </member>
        <member name="M:DryIoc.ContainerTools.RegisterPlaceholder(DryIoc.IContainer,System.Type,System.Object)">
            <summary>Register a service without implementation which can be provided later in terms
            of normal registration with IfAlreadyRegistered.Replace parameter.
            When the implementation is still not provided when the placeholder service is accessed,
            then the exception will be thrown.
            This feature allows you to postpone decision on implementation until it is later known.</summary>
            <remarks>Internally the empty factory is registered with the setup asResolutionCall set to true.
            That means, instead of placing service instance into graph expression we put here redirecting call to
            container Resolve.</remarks>
        </member>
        <member name="M:DryIoc.ContainerTools.RegisterPlaceholder``1(DryIoc.IContainer,System.Object)">
            <summary>Register a service without implementation which can be provided later in terms
            of normal registration with IfAlreadyRegistered.Replace parameter.
            When the implementation is still not provided when the placeholder service is accessed,
            then the exception will be thrown.
            This feature allows you to postpone decision on implementation until it is later known.</summary>
            <remarks>Internally the empty factory is registered with the setup asResolutionCall set to true.
            That means, instead of placing service instance into graph expression we put here redirecting call to
            container Resolve.</remarks>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackResolution(DryIoc.IContainer,System.Collections.Generic.IEnumerable{System.Type},System.Func{DryIoc.IReuse,DryIoc.Request,DryIoc.IReuse},System.Func{DryIoc.Request,System.Boolean})">
            <summary>Obsolete: please use WithAutoFallbackDynamicRegistration</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackResolution(DryIoc.IContainer,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Func{DryIoc.IReuse,DryIoc.Request,DryIoc.IReuse},System.Func{DryIoc.Request,System.Boolean})">
            <summary>Obsolete: please use WithAutoFallbackDynamicRegistration</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,System.Func{System.Type,System.Object,System.Collections.Generic.IEnumerable{System.Type}},System.Func{System.Type,DryIoc.Factory})">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath uses <see cref="M:DryIoc.Rules.WithDynamicRegistrations(DryIoc.Rules.DynamicRegistrationProvider[])"/>.</summary>
            <param name="container">Container to use.</param>
            <param name="getImplTypes">Implementation type provider.</param>
            <param name="factory">(optional) Handler to customize the factory, e.g.
            specify reuse or setup. Handler should not return <c>null</c>.</param>
            <returns>New container with corresponding rule set.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,System.Type[])">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath uses <see cref="M:DryIoc.Rules.WithDynamicRegistrations(DryIoc.Rules.DynamicRegistrationProvider[])"/>.</summary>
            <param name="container">Container to use.</param>
            <param name="implTypes">Implementation types.</param>
            <returns>New container with corresponding rule set.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,DryIoc.IReuse,System.Type[])">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath uses <see cref="M:DryIoc.Rules.WithDynamicRegistrations(DryIoc.Rules.DynamicRegistrationProvider[])"/>.</summary>
            <param name="container">Container to use.</param>
            <param name="reuse">The implementation reuse.</param>
            <param name="implTypes">Implementation types.</param>
            <returns>New container with corresponding rule set.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,DryIoc.IReuse,DryIoc.Setup,System.Type[])">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath uses <see cref="M:DryIoc.Rules.WithDynamicRegistrations(DryIoc.Rules.DynamicRegistrationProvider[])"/>.</summary>
            <param name="container">Container to use.</param>
            <param name="reuse">The implementation reuse</param>
            <param name="setup">The implementation setup, including condition</param>
            <param name="implTypes">Type to get implementations from.</param>
            <returns>New container with corresponding rule set.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,System.Func{System.Type,System.Object,System.Collections.Generic.IEnumerable{System.Reflection.Assembly}},System.Func{System.Type,DryIoc.Factory})">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath uses <see cref="M:DryIoc.Rules.WithDynamicRegistrations(DryIoc.Rules.DynamicRegistrationProvider[])"/>.</summary>
            <param name="container">Container to use.</param>
            <param name="getImplTypeAssemblies">Provides assemblies with implementation types.</param>
            <param name="factory">(optional) Handler to customize the factory, e.g.
            specify reuse or setup. Handler should not return <c>null</c>.</param>
            <returns>New container with corresponding rule set.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,System.Reflection.Assembly[])">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath uses <see cref="M:DryIoc.Rules.WithDynamicRegistrations(DryIoc.Rules.DynamicRegistrationProvider[])"/>.</summary>
            <param name="container">Container to use.</param>
            <param name="implTypeAssemblies">Assemblies with implementation types.</param>
            <returns>New container with corresponding rule set.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.WithDependencies(DryIoc.IContainer,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Creates new container with provided parameters and properties
            to pass the custom dependency values for injection. The old parameters and properties are overridden,
            but not replaced.</summary>
            <param name="container">Container to work with.</param>
            <param name="parameters">(optional) Parameters specification, can be used to proved custom values.</param>
            <param name="propertiesAndFields">(optional) Properties and fields specification, can be used to proved custom values.</param>
            <returns>New container with adjusted rules.</returns>
            <example><code lang="cs"><![CDATA[
                var c = container.WithDependencies(Parameters.Of.Type<string>(_ => "Nya!"));
                var a = c.Resolve<A>(); // where A accepts string parameter in constructor
                Assert.AreEqual("Nya!", a.Message)
            ]]></code></example>
        </member>
        <member name="F:DryIoc.ContainerTools.SetupAsResolutionRoots">
            <summary>Pre-defined what-registrations predicate for <seealso cref="M:DryIoc.ContainerTools.GenerateResolutionExpressions(DryIoc.IContainer,System.Collections.Generic.KeyValuePair{DryIoc.ServiceRegistrationInfo,System.Linq.Expressions.Expression{DryIoc.FactoryDelegate}}[]@,System.Collections.Generic.KeyValuePair{DryIoc.RequestInfo,System.Linq.Expressions.Expression}[]@,System.Func{DryIoc.ServiceRegistrationInfo,System.Boolean})"/>.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.GenerateResolutionExpressions(DryIoc.IContainer,System.Collections.Generic.KeyValuePair{DryIoc.ServiceRegistrationInfo,System.Linq.Expressions.Expression{DryIoc.FactoryDelegate}}[]@,System.Collections.Generic.KeyValuePair{DryIoc.RequestInfo,System.Linq.Expressions.Expression}[]@,System.Func{DryIoc.ServiceRegistrationInfo,System.Boolean})">
            <summary>Generates all resolution root and calls expressions.</summary>
            <param name="container">For container</param>
            <param name="resolutions">Result resolution factory expressions. They could be compiled and used for actual service resolution.</param>
            <param name="resolutionCallDependencies">Resolution call dependencies (implemented via Resolve call): e.g. dependencies wrapped in Lazy{T}.</param>
            <param name="whatRegistrations">(optional) Allow to filter what registration to resolve. By default applies to all registrations.
            You may use <see cref="F:DryIoc.ContainerTools.SetupAsResolutionRoots"/> to generate only for registrations with <see cref="P:DryIoc.Setup.AsResolutionRoot"/>.</param>
            <returns>Errors happened when resolving corresponding registrations.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.Validate(DryIoc.IContainer,System.Type[])">
            <summary>Used to find potential problems when resolving the passed services <paramref name="resolutionRoots"/>.
            Method will collect the exceptions when resolving or injecting the specific registration.
            Does not create any actual service objects.</summary>
            <param name="container">for container</param>
            <param name="resolutionRoots">(optional) Examined resolved services. If empty will try to resolve every service in container.</param>
            <returns>Exceptions happened for corresponding registrations.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.VerifyResolutions(DryIoc.IContainer,System.Func{DryIoc.ServiceRegistrationInfo,System.Boolean})">
            <summary>Used to find potential problems in service registration setup.
            Method tries to get expressions for Roots/All registrations, collects happened exceptions, and
            returns them to user. Does not create any actual service objects.</summary>
            <param name="container">for container</param>
            <param name="whatRegistrations">(optional) Allow to filter what registration to resolve. By default applies to all registrations.</param>
            <returns>Exceptions happened for corresponding registrations.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.IsSupportedInjectedCustomValueType(System.Type)">
            <summary>Checks if custom value of the <paramref name="customValueType"/> is supported by DryIoc injection mechanism.</summary>
            <param name="customValueType">Type to check</param> <returns>True if supported, false otherwise.c</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.RequestInfoToExpression(DryIoc.IContainer,DryIoc.RequestInfo)">
            <summary>Represents construction of whole request info stack as expression.</summary>
            <param name="container">Required to access container facilities for expression conversion.</param>
            <param name="request">Request info to convert to expression.</param>
            <returns>Returns result expression.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.GetCurrentScope(DryIoc.IContainer,System.Object,System.Boolean)">
            <summary>Returns the current scope, or null if not opened and <paramref name="throwIfNotFound"/> is not set.</summary>
            <param name="container">Container with scope to check.</param>
            <param name="name">(optional) Name of scope to search in current scope or its parents.</param>
            <param name="throwIfNotFound">(optional) Dictates to throw exception if scope if not found.</param>
            <returns>Scope if found, or null otherwise (if <paramref name="throwIfNotFound"/> is not set).</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.ClearCache``1(DryIoc.IContainer,System.Nullable{DryIoc.FactoryType},System.Object)">
            <summary>Clears delegate and expression cache for specified <typeparamref name="T"/>.
            But does not clear instances of already resolved/created singletons and scoped services!</summary>
            <typeparam name="T">Target service or wrapper type.</typeparam>
            <param name="container">Container to operate.</param>
            <param name="factoryType">(optional) If not specified, clears cache for all <see cref="T:DryIoc.FactoryType"/>.</param>
            <param name="serviceKey">(optional) If omitted, the cache will be cleared for all registrations of <typeparamref name="T"/>.</param>
            <returns>True if type is found in the cache and cleared - false otherwise.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.ClearCache(DryIoc.IContainer,System.Type,System.Nullable{DryIoc.FactoryType},System.Object)">
            <summary>Clears delegate and expression cache for specified service.
            But does not clear instances of already resolved/created singletons and scoped services!</summary>
            <param name="container">Container to operate.</param>
            <param name="serviceType">Target service type.</param>
            <param name="factoryType">(optional) If not specified, clears cache for all <see cref="T:DryIoc.FactoryType"/>.</param>
            <param name="serviceKey">(optional) If omitted, the cache will be cleared for all registrations of <paramref name="serviceType"/>.</param>
            <returns>True if type is found in the cache and cleared - false otherwise.</returns>
        </member>
        <member name="T:DryIoc.IConvertibleToExpression">
            <summary>Interface used to convert reuse instance to expression.</summary>
        </member>
        <member name="M:DryIoc.IConvertibleToExpression.ToExpression(System.Func{System.Object,System.Linq.Expressions.Expression})">
            <summary>Returns expression representation without closure.</summary>
            <param name="fallbackConverter">Delegate converting of sub-items, constants to container.</param>
            <returns>Expression representation.</returns>
        </member>
        <member name="T:DryIoc.DefaultKey">
            <summary>Used to represent multiple default service keys.
            Exposes <see cref="F:DryIoc.DefaultKey.RegistrationOrder"/> to determine order of service added.</summary>
        </member>
        <member name="F:DryIoc.DefaultKey.Value">
            <summary>Default value.</summary>
        </member>
        <member name="F:DryIoc.DefaultKey.RegistrationOrder">
            <summary>Allows to determine service registration order.</summary>
        </member>
        <member name="M:DryIoc.DefaultKey.Of(System.Int32)">
            <summary>Create new default key with specified registration order.</summary>
            <param name="registrationOrder"></param> <returns>New default key.</returns>
        </member>
        <member name="M:DryIoc.DefaultKey.Next">
            <summary>Returns next default key with increased <see cref="F:DryIoc.DefaultKey.RegistrationOrder"/>.</summary>
            <returns>New key.</returns>
        </member>
        <member name="M:DryIoc.DefaultKey.Equals(System.Object)">
            <summary>Compares keys based on registration order.</summary>
            <param name="key">Key to compare with.</param>
            <returns>True if keys have the same order.</returns>
        </member>
        <member name="M:DryIoc.DefaultKey.GetHashCode">
            <summary>Returns registration order as hash.</summary> <returns>Hash code.</returns>
        </member>
        <member name="M:DryIoc.DefaultKey.ToString">
            <summary>Prints registration order to string.</summary> <returns>Printed string.</returns>
        </member>
        <member name="T:DryIoc.DefaultDynamicKey">
            <summary>Represents default key for dynamic registrations</summary>
        </member>
        <member name="F:DryIoc.DefaultDynamicKey.Empty">
            <summary>Default value.</summary>
        </member>
        <member name="F:DryIoc.DefaultDynamicKey.ID">
            <summary>Associated ID.</summary>
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.Of(System.Int32)">
            <summary>Returns dynamic key with specified ID. The key itself may be non unique, and requested from pool.</summary>
            <param name="id">Associated ID.</param> <returns>The key.</returns>
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.Next">
            <summary>Returns next dynamic key with increased <see cref="F:DryIoc.DefaultDynamicKey.ID"/>.</summary> <returns>Next key.</returns>
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.Equals(System.Object)">
            <summary>Compares key's IDs.</summary> <param name="key">Key to compare with.</param>
            <returns>True if keys have the same IDs.</returns>
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.GetHashCode">
            <summary>Returns key index as hash.</summary> <returns>Hash code.</returns>
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.ToString">
            <summary>Prints registration order to string.</summary> <returns>Printed string.</returns>
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.ToExpression(System.Func{System.Object,System.Linq.Expressions.Expression})">
            <inheritdoc />
        </member>
        <member name="T:DryIoc.IResolverContext">
            <summary>Provides access to Container for compiled factory delegate.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.Resolver">
            <summary>Provides access to current / scoped resolver.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.Scopes">
            <summary>Access to the singleton and current scopes.</summary>
        </member>
        <member name="T:DryIoc.ResolverContext">
            <summary>Provides the shortcuts to <see cref="T:DryIoc.IResolverContext"/></summary>
        </member>
        <member name="M:DryIoc.ResolverContext.RootResolver(DryIoc.IResolverContext)">
            <summary>Returns subj.</summary>
            <param name="ctx"></param> <returns></returns>
        </member>
        <member name="M:DryIoc.ResolverContext.RootScopes(DryIoc.IResolverContext)">
            <summary>Returns subj.</summary>
            <param name="ctx"></param> <returns></returns>
        </member>
        <member name="M:DryIoc.ResolverContext.SingletonScope(DryIoc.IResolverContext)">
            <summary>Returns subj.</summary>
            <param name="ctx"></param> <returns></returns>
        </member>
        <member name="T:DryIoc.ContainerWeakRef">
            <summary>Provides access to Container from compiled factory delegate.</summary>
        </member>
        <member name="P:DryIoc.ContainerWeakRef.Resolver">
            <summary>Provides access to current / scoped resolver.</summary>
        </member>
        <member name="P:DryIoc.ContainerWeakRef.Scopes">
            <summary>Access to the singleton and current scopes.</summary>
        </member>
        <member name="P:DryIoc.ContainerWeakRef.Container">
            <summary>Container access.</summary>
        </member>
        <member name="M:DryIoc.ContainerWeakRef.RootContainerOrSelf">
            <summary>Returns root container (the same as container if its already the root).
            Throws exception if root is disposed.</summary>
            <returns>Container</returns>
        </member>
        <member name="M:DryIoc.ContainerWeakRef.#ctor(DryIoc.Container,DryIoc.Container)">
            <summary>Creates weak reference wrapper over passed container object.</summary>
            <param name="container">Container to reference.</param>
            <param name="rootContainer">(optional) Root container - the same as <paramref name="container"/> for root container.</param>
        </member>
        <member name="T:DryIoc.FactoryDelegate">
            <summary>The delegate type which is actually used to create service instance by container.
            Delegate instance required to be static with all information supplied by <paramref name="state"/> and <paramref name="scope"/>
            parameters. The requirement is due to enable compilation to DynamicMethod in DynamicAssembly, and also to simplify
            state management and minimizes memory leaks.</summary>
            <param name="state">All the state items available in resolution root.</param>
            <param name="r">Provides access to <see cref="T:DryIoc.IResolver"/> implementation to enable nested/dynamic resolve inside:
            registered delegate factory, <see cref="T:System.Lazy`1"/>, and <see cref="T:DryIoc.LazyEnumerable`1"/>.</param>
            <param name="scope">Resolution root scope: initially passed value will be null, but then the actual will be created on demand.</param>
            <returns>Created service object.</returns>
        </member>
        <member name="T:DryIoc.WrappersSupport">
            <summary>Adds to Container support for:
            <list type="bullet">
            <item>Open-generic services</item>
            <item>Service generics wrappers and arrays using <see cref="P:DryIoc.Rules.UnknownServiceResolvers"/> extension point.
            Supported wrappers include: Func of <see cref="F:DryIoc.WrappersSupport.FuncTypes"/>, Lazy, Many, IEnumerable, arrays, Meta, KeyValuePair, DebugExpression.
            All wrapper factories are added into collection of <see cref="F:DryIoc.WrappersSupport.Wrappers"/>.
            unregistered resolution rule.</item>
            </list></summary>
        </member>
        <member name="F:DryIoc.WrappersSupport.FuncTypes">
            <summary>Supported Func types.</summary>
        </member>
        <member name="F:DryIoc.WrappersSupport.ActionTypes">
            <summary>Supported Action types. Yeah, action I can resolve or inject void returning method as action.</summary>
        </member>
        <member name="F:DryIoc.WrappersSupport.ArrayInterfaces">
            <summary>Supported open-generic collection types.</summary>
        </member>
        <member name="M:DryIoc.WrappersSupport.IsSupportedCollectionType(System.Type)">
            <summary>Checks if passed type represents supported collection types.</summary>
            <param name="type">Type to examine.</param> <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.WrappersSupport.IsFunc(System.Type)">
            <summary>Returns true if type is supported <see cref="F:DryIoc.WrappersSupport.FuncTypes"/>, and false otherwise.</summary>
            <param name="type">Type to check.</param><returns>True for func type, false otherwise.</returns>
        </member>
        <member name="M:DryIoc.WrappersSupport.IsFuncWithArgs(System.Type)">
            <summary>Returns true if type is Func with 1 or more input arguments.</summary>
            <param name="type">Type to check.</param><returns>True for Func type, false otherwise.</returns>
        </member>
        <member name="F:DryIoc.WrappersSupport.Wrappers">
            <summary>Registered wrappers by their concrete or generic definition service type.</summary>
        </member>
        <member name="M:DryIoc.WrappersSupport.GetLazyExpressionOrDefault(DryIoc.Request,System.Boolean)">
            <summary>Gets the expression for <see cref="T:System.Lazy`1"/> wrapper.</summary>
            <param name="request">The resolution request.</param>
            <param name="nullWrapperForUnresolvedService">if set to <c>true</c> then check for service registration before creating resolution expression.</param>
            <returns>Expression: r => new Lazy{TService}(() => r.Resolver.Resolve{TService}(key, ifUnresolved, requiredType));</returns>
        </member>
        <member name="M:DryIoc.WrappersSupport.GetMetaExpressionOrDefault(DryIoc.Request)">
            <summary>Discovers and combines service with its setup metadata.
            Works with any generic type with first Type arg - Service type and second Type arg - Metadata type,
            and constructor with Service and Metadata arguments respectively.
            - if service key is not specified in request then method will search for all
            registered factories with the same metadata type ignoring keys.
            - if metadata is IDictionary{string, object},
             then the First value matching the TMetadata type will be returned.</summary>
            <param name="request">Requested service.</param>
            <returns>Wrapper creation expression.</returns>
        </member>
        <member name="T:DryIoc.DynamicRegistration">
            <summary>Represents info required for dynamic registration: service key, factory,
            and <see cref="F:DryIoc.DynamicRegistration.IfAlreadyRegistered"/> option how to combine dynamic with normal registrations.</summary>
        </member>
        <member name="F:DryIoc.DynamicRegistration.Factory">
            <summary>Factory</summary>
        </member>
        <member name="F:DryIoc.DynamicRegistration.IfAlreadyRegistered">
            <summary>Optional: will be <see cref="F:DryIoc.IfAlreadyRegistered.AppendNotKeyed"/> by default.</summary>
        </member>
        <member name="F:DryIoc.DynamicRegistration.ServiceKey">
            <summary>Optional service key: if null the default <see cref="T:DryIoc.DefaultDynamicKey"/> will be used. </summary>
        </member>
        <member name="M:DryIoc.DynamicRegistration.#ctor(DryIoc.Factory,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Constructs the info</summary>
            <param name="factory"></param>
            <param name="ifAlreadyRegistered">(optional) Defines how to combine with normal registrations.
            Will use <see cref="F:DryIoc.IfAlreadyRegistered.AppendNotKeyed"/> by default.</param>
            <param name="serviceKey">(optional) Service key.</param>
        </member>
        <member name="T:DryIoc.Rules">
            <summary> Defines resolution/registration rules associated with Container instance. They may be different for different containers.</summary>
        </member>
        <member name="F:DryIoc.Rules.Default">
            <summary>No rules as staring point.</summary>
        </member>
        <member name="F:DryIoc.Rules.DefaultMaxObjectGraphSize">
            <summary>Default value for <see cref="P:DryIoc.Rules.MaxObjectGraphSize"/></summary>
        </member>
        <member name="P:DryIoc.Rules.MaxObjectGraphSize">
            <summary>Max number of dependencies including nested ones,
            before splitting the graph with Resolve calls.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithMaxObjectGraphSize(System.Int32)">
            <summary>Sets <see cref="P:DryIoc.Rules.MaxObjectGraphSize"/>.
            To disable the limit please use <see cref="M:DryIoc.Rules.WithoutMaxObjectGraphSize"/></summary>
            <param name="size">New  value. Should be <c>1</c> or higher.</param>
            <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Rules.WithoutMaxObjectGraphSize">
            <summary>Disables the <see cref="P:DryIoc.Rules.MaxObjectGraphSize"/> limitation,
            so that object graph won't be split due this setting.</summary>
            <returns>New rules.</returns>
        </member>
        <member name="P:DryIoc.Rules.LevelToSplitObjectGraphIntoResolveCalls">
            <summary>Obsolete: replaced with <see cref="P:DryIoc.Rules.MaxObjectGraphSize"/></summary>
        </member>
        <member name="P:DryIoc.Rules.FactoryMethod">
            <summary>Shorthand to <see cref="P:DryIoc.Made.FactoryMethod"/></summary>
        </member>
        <member name="P:DryIoc.Rules.Parameters">
            <summary>Shorthand to <see cref="P:DryIoc.Made.Parameters"/></summary>
        </member>
        <member name="P:DryIoc.Rules.PropertiesAndFields">
            <summary>Shorthand to <see cref="P:DryIoc.Made.PropertiesAndFields"/></summary>
        </member>
        <member name="P:DryIoc.Rules.OverrideRegistrationMade">
            <summary>Instructs to override per-registration made settings with these rules settings.</summary>
        </member>
        <member name="M:DryIoc.Rules.With(DryIoc.FactoryMethodSelector,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Returns new instance of the rules new Made composed out of
            provided factory method, parameters, propertiesAndFields.</summary>
            <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Rules.With(DryIoc.Made,System.Boolean)">
            <summary>Returns new instance of the rules with specified <see cref="T:DryIoc.Made"/>.</summary>
            <param name="made">New Made.Of rules.</param>
            <param name="overrideRegistrationMade">Instructs to override registration level Made.Of</param>
            <returns>New rules.</returns>
        </member>
        <member name="T:DryIoc.Rules.FactorySelectorRule">
            <summary>Defines single factory selector delegate.</summary>
            <param name="request">Provides service request leading to factory selection.</param>
            <param name="factories">Registered factories with corresponding key to select from.</param>
            <returns>Single selected factory, or null if unable to select.</returns>
        </member>
        <member name="P:DryIoc.Rules.FactorySelector">
            <summary>Rules to select single matched factory default and keyed registered factory/factories.
            Selectors applied in specified array order, until first returns not null <see cref="T:DryIoc.Factory"/>.
            Default behavior is throw on multiple registered default factories, cause it is not obvious what to use.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithFactorySelector(DryIoc.Rules.FactorySelectorRule)">
            <summary>Sets <see cref="P:DryIoc.Rules.FactorySelector"/></summary>
            <param name="rule">Selectors to set, could be null to use default approach.</param> <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Rules.SelectLastRegisteredFactory">
            <summary>Select last registered factory from multiple default.</summary>
            <returns>Factory selection rule.</returns>
        </member>
        <member name="M:DryIoc.Rules.SelectKeyedOverDefaultFactory(System.Object)">
            <summary>Prefer specified service key (if found) over default key.
            Help to override default registrations in Open Scope scenarios:
            I may register service with key and resolve it as default in current scope.</summary>
            <param name="serviceKey">Service key to look for instead default.</param>
            <returns>Found factory or null.</returns>
        </member>
        <member name="T:DryIoc.Rules.DynamicRegistrationProvider">
            <summary>Specify the method signature for returning multiple keyed factories.
            This is dynamic analog to the normal Container Registry.</summary>
            <param name="serviceType">Requested service type.</param>
            <param name="serviceKey">(optional) If <c>null</c> will request all factories of <paramref name="serviceType"/></param>
            <returns>Key-Factory pairs.</returns>
        </member>
        <member name="P:DryIoc.Rules.DynamicRegistrationProviders">
            <summary>Providers for resolving multiple not-registered services. Null by default.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDynamicRegistrations(DryIoc.Rules.DynamicRegistrationProvider[])">
            <summary>Appends dynamic registration rules.</summary>
            <param name="rules">Rules to append.</param> <returns>New Rules.</returns>
        </member>
        <member name="M:DryIoc.Rules.WithDynamicRegistrationsAsFallback(DryIoc.Rules.DynamicRegistrationProvider[])">
            <summary>Appends dynamic registration rules 
            And additionally specifies to use dynamic registrations only when no normal registrations found!</summary>
            <param name="rules">Rules to append.</param> <returns>New Rules.</returns>
        </member>
        <member name="P:DryIoc.Rules.UseDynamicRegistrationsAsFallback">
            <summary>Specifies to use dynamic registrations only when no normal registrations found</summary>
        </member>
        <member name="T:DryIoc.Rules.UnknownServiceResolver">
            <summary>Defines delegate to return factory for request not resolved by registered factories or prior rules.
            Applied in specified array order until return not null <see cref="T:DryIoc.Factory"/>.</summary>
            <param name="request">Request to return factory for</param> <returns>Factory to resolve request, or null if unable to resolve.</returns>
        </member>
        <member name="P:DryIoc.Rules.UnknownServiceResolvers">
            <summary>Gets rules for resolving not-registered services. Null by default.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithUnknownServiceResolvers(DryIoc.Rules.UnknownServiceResolver[])">
            <summary>Appends resolver to current unknown service resolvers.</summary>
            <param name="rules">Rules to append.</param> <returns>New Rules.</returns>
        </member>
        <member name="M:DryIoc.Rules.WithoutUnknownServiceResolver(DryIoc.Rules.UnknownServiceResolver)">
            <summary>Removes specified resolver from unknown service resolvers, and returns new Rules.
            If no resolver was found then <see cref="P:DryIoc.Rules.UnknownServiceResolvers"/> will stay the same instance,
            so it could be check for remove success or fail.</summary>
            <param name="rule">Rule tor remove.</param> <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Rules.WithUnknownServiceHandler(System.Action{DryIoc.Request})">
            <summary>Sugar on top of <see cref="M:DryIoc.Rules.WithUnknownServiceResolvers(DryIoc.Rules.UnknownServiceResolver[])"/> to simplify setting the diagnostic action.
            Does not guard you from action throwing an exception. Actually can be used to throw your custom exception
            instead of <see cref="T:DryIoc.ContainerException"/>.</summary>
            <param name="handler">May be a Logger action or any other diagnostic handler.</param>
            <returns>Rules with unknown resolver.</returns>
        </member>
        <member name="M:DryIoc.Rules.AutoResolveConcreteTypeRule(System.Func{DryIoc.Request,System.Boolean})">
            <summary>Obsolete: Replaced by ConcreteTypeDynamicRegistrations</summary>
        </member>
        <member name="M:DryIoc.Rules.ConcreteTypeDynamicRegistrations(System.Func{System.Type,System.Object,System.Boolean},DryIoc.IReuse)">
            <summary>Rule to automatically resolves non-registered service type which is: nor interface, nor abstract.
            For constructor selection we are using <see cref="F:DryIoc.FactoryMethod.ConstructorWithResolvableArguments"/>.
            The resolution creates transient services.</summary>
            <param name="condition">(optional) Condition for requested service type and key.</param>
            <param name="reuse">(optional) Reuse.</param>
            <returns>New rule.</returns>
        </member>
        <member name="M:DryIoc.Rules.WithConcreteTypeDynamicRegistrations(System.Func{System.Type,System.Object,System.Boolean},DryIoc.IReuse)">
            <summary>Automatically resolves non-registered service type which is: nor interface, nor abstract.
            The resolution creates Transient services.</summary>
            <param name="condition">(optional) Condition for requested service type and key.</param>
            <param name="reuse">(optional) Reuse.</param>
            <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Rules.WithAutoConcreteTypeResolution(System.Func{DryIoc.Request,System.Boolean})">
            <summary>Replaced with WithConcreteTypeDynamicRegistrations</summary>
        </member>
        <member name="M:DryIoc.Rules.AutoFallbackDynamicRegistrations(System.Func{System.Type,System.Object,System.Collections.Generic.IEnumerable{System.Type}},System.Func{System.Type,DryIoc.Factory})">
            <summary>Creates dynamic fallback registrations for the requested service type
            with provided <paramref name="getImplementationTypes"/>.
            Fallback means that the dynamic registrations will be applied Only if no normal registrations
            exist for the requested service type, hence the "fallback".</summary>
            <param name="getImplementationTypes">Implementation types to select for service.</param>
            <param name="factory">(optional) Handler to customize the factory, e.g.
            specify reuse or setup. Handler should not return <c>null</c>.</param>
            <returns>Registration provider.</returns>
        </member>
        <member name="M:DryIoc.Rules.AutoRegisterUnknownServiceRule(System.Collections.Generic.IEnumerable{System.Type},System.Func{DryIoc.IReuse,DryIoc.Request,DryIoc.IReuse},System.Func{DryIoc.Request,System.Boolean})">
            <summary>Obsolete: replaced by <see cref="M:DryIoc.Rules.AutoFallbackDynamicRegistrations(System.Func{System.Type,System.Object,System.Collections.Generic.IEnumerable{System.Type}},System.Func{System.Type,DryIoc.Factory})"/></summary>
        </member>
        <member name="P:DryIoc.Rules.FallbackContainers">
            <summary>List of containers to fallback resolution to.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithFallbackContainer(DryIoc.IContainer)">
            <summary>Appends WeakReference to new fallback container to the end of the list.</summary>
            <param name="container">To append.</param> <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Rules.WithoutFallbackContainer(DryIoc.IContainer)">
            <summary>Removes WeakReference to fallback container from the list.</summary>
            <param name="container">To remove.</param> <returns>New rules.</returns>
        </member>
        <member name="P:DryIoc.Rules.DefaultReuseInsteadOfTransient">
            <summary>See <see cref="M:DryIoc.Rules.WithDefaultReuseInsteadOfTransient(DryIoc.IReuse)"/></summary>
        </member>
        <member name="M:DryIoc.Rules.WithDefaultReuseInsteadOfTransient(DryIoc.IReuse)">
            <summary>Replaced by WithDefaultReuse because for some cases IsteadOfTransient does not make sense.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDefaultReuse(DryIoc.IReuse)">
            <summary>The reuse used in case if reuse is unspecified (null) in Register methods.</summary>
            <param name="reuse">Reuse to set. If null the <see cref="F:DryIoc.Reuse.Transient"/> will be used</param>
            <returns>New rules.</returns>
        </member>
        <member name="T:DryIoc.Rules.ItemToExpressionConverterRule">
            <summary>Given item object and its type should return item "pure" expression presentation,
            without side-effects or external dependencies.
            e.g. for string "blah" <code lang="cs"><![CDATA[]]>Expression.Constant("blah", typeof(string))</code>.
            If unable to convert should return null.</summary>
            <param name="item">Item object. Item is not null.</param>
            <param name="itemType">Item type. Item type is not null.</param>
            <returns>Expression or null.</returns>
        </member>
        <member name="P:DryIoc.Rules.ItemToExpressionConverter">
            <summary><see cref="M:DryIoc.Rules.WithItemToExpressionConverter(DryIoc.Rules.ItemToExpressionConverterRule)"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithItemToExpressionConverter(DryIoc.Rules.ItemToExpressionConverterRule)">
            <summary>Specifies custom rule to convert non-primitive items to their expression representation.
            That may be required because DryIoc by default does not support non-primitive service keys and registration metadata.
            To enable non-primitive values support DryIoc need a way to recreate them as expression tree.</summary>
            <returns>New rules</returns>
        </member>
        <member name="P:DryIoc.Rules.ThrowIfDependencyHasShorterReuseLifespan">
            <summary><see cref="M:DryIoc.Rules.WithoutThrowIfDependencyHasShorterReuseLifespan"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutThrowIfDependencyHasShorterReuseLifespan">
            <summary>Turns off throwing exception when dependency has shorter reuse lifespan than its parent or ancestor.</summary>
            <returns>New rules with new setting value.</returns>
        </member>
        <member name="P:DryIoc.Rules.ThrowOnRegisteringDisposableTransient">
            <summary><see cref="M:DryIoc.Rules.WithoutThrowOnRegisteringDisposableTransient"/></summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutThrowOnRegisteringDisposableTransient">
            <summary>Turns Off the rule <see cref="P:DryIoc.Rules.ThrowOnRegisteringDisposableTransient"/>.
            Allows to register disposable transient but it is up to you to handle their disposal.
            You can use <see cref="M:DryIoc.Rules.WithTrackingDisposableTransients"/> to actually track disposable transient in
            container, so that disposal will be handled by container.</summary>
            <returns>New rules with setting turned off.</returns>
        </member>
        <member name="P:DryIoc.Rules.TrackingDisposableTransients">
            <summary><see cref="M:DryIoc.Rules.WithTrackingDisposableTransients"/></summary>
        </member>
        <member name="M:DryIoc.Rules.WithTrackingDisposableTransients">
             <summary>Turns tracking of disposable transients in dependency parent scope, or in current scope if service
             is resolved directly.
            
             If no open scope at the moment then resolved transient won't be tracked and it is up to you
             to dispose it! That's is similar situation to creating service by new - you have full control.
            
             If dependency wrapped in Func somewhere in parent chain then it also won't be tracked, because
             Func supposedly means multiple object creation and for container it is not clear what to do, so container
             delegates that to user. Func here is the similar to Owned relationship type in Autofac library.
             </summary>
             <remarks>Turning this setting On automatically turns off <see cref="P:DryIoc.Rules.ThrowOnRegisteringDisposableTransient"/>.</remarks>
             <returns>New rules with setting turned On.</returns>
        </member>
        <member name="P:DryIoc.Rules.EagerCachingSingletonForFasterAccess">
            <summary><see cref="M:DryIoc.Rules.WithoutEagerCachingSingletonForFasterAccess"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutEagerCachingSingletonForFasterAccess">
            <summary>Turns off optimization: creating singletons during resolution of object graph.</summary>
            <returns>New rules with singleton optimization turned off.</returns>
        </member>
        <member name="P:DryIoc.Rules.DependencyResolutionCallExpressions">
            <summary><see cref="M:DryIoc.Rules.WithDependencyResolutionCallExpressions"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDependencyResolutionCallExpressions">
            <summary>Specifies to generate ResolutionCall dependency creation expression
            and put it into collection.</summary>
            <returns>New rules with resolution call expressions to be populated.</returns>
        </member>
        <member name="P:DryIoc.Rules.ImplicitCheckForReuseMatchingScope">
            <summary><see cref="P:DryIoc.Rules.ImplicitCheckForReuseMatchingScope"/></summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutImplicitCheckForReuseMatchingScope">
            <summary>Removes implicit Factory <see cref="P:DryIoc.Setup.Condition"/> for non-transient service.
            The Condition filters out factory without matching scope.</summary>
            <returns>Returns new rules with flag set.</returns>
        </member>
        <member name="P:DryIoc.Rules.ResolveIEnumerableAsLazyEnumerable">
            <summary><see cref="M:DryIoc.Rules.WithResolveIEnumerableAsLazyEnumerable"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithResolveIEnumerableAsLazyEnumerable">
            <summary>Specifies to resolve IEnumerable as LazyEnumerable.</summary>
            <returns>Returns new rules with flag set.</returns>
        </member>
        <member name="P:DryIoc.Rules.VariantGenericTypesInResolvedCollection">
            <summary><see cref="M:DryIoc.Rules.WithoutVariantGenericTypesInResolvedCollection"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutVariantGenericTypesInResolvedCollection">
            <summary>Flag instructs to include covariant compatible types in resolved collection.</summary>
            <returns>Returns new rules with flag set.</returns>
        </member>
        <member name="P:DryIoc.Rules.DefaultIfAlreadyRegistered">
            <summary><seew cref="M:DryIoc.Rules.WithDefaultIfAlreadyRegistered(DryIoc.IfAlreadyRegistered)"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDefaultIfAlreadyRegistered(DryIoc.IfAlreadyRegistered)">
            <summary>Specifies default setting for container. By default is <see cref="F:DryIoc.IfAlreadyRegistered.AppendNotKeyed"/>.
            Example of use: specify Keep as a container default, then set AppendNonKeyed for explicit collection registrations.</summary>
            <param name="rule">New setting.</param> <returns>New rules.</returns>
        </member>
        <member name="P:DryIoc.Rules.ImplicitOpenedRootScope">
            <summary><see cref="M:DryIoc.Rules.WithImplicitRootOpenScope"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithImplicitRootOpenScope">
            <summary>Specifies to open scope as soon as container is created (the same as for Singleton scope).
            That way you don't need to call <see cref="M:DryIoc.IContainer.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})"/>.
            Implicitly opened scope will be disposed together with Singletons when container is disposed.
            The name of root scope is <see cref="F:DryIoc.Container.NonAmbientRootScopeName"/>.</summary>
            <remarks>The setting is only valid for container without ambient scope context.</remarks>
            <returns>Returns new rules with flag set.</returns>
        </member>
        <member name="P:DryIoc.Rules.ThrowIfRuntimeStateRequired">
            <summary><see cref="M:DryIoc.Rules.WithThrowIfRuntimeStateRequired"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithThrowIfRuntimeStateRequired">
            <summary>Specifies to throw an exception in attempt to resolve service which require runtime state for resolution.
            Runtime state may be introduced by RegisterDelegate, RegisterInstance, or registering with non-primitive service key, or metadata.</summary>
            <returns>Returns new rules with flag set.</returns>
        </member>
        <member name="P:DryIoc.Rules.CaptureContainerDisposeStackTrace">
            <summary><see cref="M:DryIoc.Rules.WithCaptureContainerDisposeStackTrace"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithCaptureContainerDisposeStackTrace">
            <summary>Instructs to capture Dispose stack-trace to include it later into <see cref="F:DryIoc.Error.ContainerIsDisposed"/>
            exception for easy diagnostics.</summary> <returns>New rules with option set.</returns>
        </member>
        <member name="T:DryIoc.FactoryMethod">
            <summary>Wraps constructor or factory method optionally with factory instance to create service.</summary>
        </member>
        <member name="F:DryIoc.FactoryMethod.ConstructorOrMethodOrMember">
            <summary>Constructor or method to use for service creation.</summary>
        </member>
        <member name="F:DryIoc.FactoryMethod.FactoryServiceInfo">
            <summary>Identifies factory service if factory method is instance member.</summary>
        </member>
        <member name="M:DryIoc.FactoryMethod.Of(System.Reflection.MemberInfo,DryIoc.ServiceInfo)">
            <summary>Wraps method and factory instance.</summary>
            <param name="ctorOrMethodOrMember">Constructor, static or instance method, property or field.</param>
            <param name="factoryInfo">Factory info to resolve in case of instance <paramref name="ctorOrMethodOrMember"/>.</param>
            <returns>New factory method wrapper.</returns>
        </member>
        <member name="M:DryIoc.FactoryMethod.Of``1(System.String)">
            <summary>Discovers the static factory method or member by name in <typeparamref name="TFactory"/>.
            Should play nice with C# <c>nameof</c> operator.</summary>
            <param name="methodOrMemberName">Name or method or member.</param>
            <typeparam name="TFactory">Class with static member.</typeparam>
            <returns>Factory method info.</returns>
        </member>
        <member name="M:DryIoc.FactoryMethod.ToString">
            <summary>Pretty prints wrapped method.</summary> <returns>Printed string.</returns>
        </member>
        <member name="M:DryIoc.FactoryMethod.Constructor(System.Boolean,System.Boolean)">
            <summary>Easy way to specify non-public and most resolvable constructor.</summary>
            <param name="mostResolvable">(optional) Instructs to select constructor with max number of params which all are resolvable.</param>
            <param name="includeNonPublic">(optional) Consider the non-public constructors.</param>
            <returns>Constructor or null if not found.</returns>
        </member>
        <member name="M:DryIoc.FactoryMethod.DefaultConstructor(System.Boolean)">
            <summary>Easy way to specify non-public or / and most resolvable constructor.</summary>
            <param name="includeNonPublic">(optional) Consider the non-public constructors.</param>
            <returns>Constructor or null if not found.</returns>
        </member>
        <member name="F:DryIoc.FactoryMethod.ConstructorWithResolvableArguments">
            <summary>Searches for public constructor with most resolvable parameters or throws <see cref="T:DryIoc.ContainerException"/> if not found.
            Works both for resolving service and Func{TArgs..., TService}</summary>
        </member>
        <member name="F:DryIoc.FactoryMethod.ConstructorWithResolvableArgumentsIncludingNonPublic">
            <summary>Searches for constructor (including non public ones) with most
            resolvable parameters or throws <see cref="T:DryIoc.ContainerException"/> if not found.
            Works both for resolving service and Func{TArgs..., TService}</summary>
        </member>
        <member name="M:DryIoc.FactoryMethod.IsResolvableParameter(System.Reflection.ParameterInfo,System.Func{System.Reflection.ParameterInfo,DryIoc.ParameterServiceInfo},DryIoc.Request)">
            <summary>Checks that parameter is selected on requested path and with provided parameter selector.</summary>
            <param name="parameter"></param> <param name="parameterSelector"></param> <param name="request"></param>
            <returns>True if parameter is resolvable.</returns>
        </member>
        <member name="T:DryIoc.Made">
            <summary>Rules how to: <list type="bullet">
            <item>Select constructor for creating service with <see cref="P:DryIoc.Made.FactoryMethod"/>.</item>
            <item>Specify how to resolve constructor parameters with <see cref="P:DryIoc.Made.Parameters"/>.</item>
            <item>Specify what properties/fields to resolve and how with <see cref="P:DryIoc.Made.PropertiesAndFields"/>.</item>
            </list></summary>
        </member>
        <member name="P:DryIoc.Made.FactoryMethod">
            <summary>Returns delegate to select constructor based on provided request.</summary>
        </member>
        <member name="P:DryIoc.Made.FactoryMethodKnownResultType">
            <summary>Return type of strongly-typed factory method expression.</summary>
        </member>
        <member name="P:DryIoc.Made.HasCustomDependencyValue">
            <summary>True is made has properties or parameters with custom value.
            That's mean the whole made become context based which affects caching</summary>
        </member>
        <member name="P:DryIoc.Made.Parameters">
            <summary>Specifies how constructor parameters should be resolved:
            parameter service key and type, throw or return default value if parameter is unresolved.</summary>
        </member>
        <member name="P:DryIoc.Made.PropertiesAndFields">
            <summary>Specifies what <see cref="T:DryIoc.ServiceInfo"/> should be used when resolving property or field.</summary>
        </member>
        <member name="F:DryIoc.Made.Default">
            <summary>Container will use some sensible defaults for service creation.</summary>
        </member>
        <member name="M:DryIoc.Made.op_Implicit(DryIoc.FactoryMethodSelector)~DryIoc.Made">
            <summary>Creates rules with only <see cref="P:DryIoc.Made.FactoryMethod"/> specified.</summary>
            <param name="factoryMethod">To use.</param> <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Made.op_Implicit(DryIoc.ParameterSelector)~DryIoc.Made">
            <summary>Creates rules with only <see cref="P:DryIoc.Made.Parameters"/> specified.</summary>
            <param name="parameters">To use.</param> <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Made.op_Implicit(DryIoc.PropertiesAndFieldsSelector)~DryIoc.Made">
            <summary>Creates rules with only <see cref="P:DryIoc.Made.PropertiesAndFields"/> specified.</summary>
            <param name="propertiesAndFields">To use.</param> <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Made.Of(DryIoc.FactoryMethodSelector,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Specifies injections rules for Constructor, Parameters, Properties and Fields. If no rules specified returns <see cref="F:DryIoc.Made.Default"/> rules.</summary>
            <param name="factoryMethod">(optional)</param> <param name="parameters">(optional)</param> <param name="propertiesAndFields">(optional)</param>
            <returns>New injection rules or <see cref="F:DryIoc.Made.Default"/>.</returns>
        </member>
        <member name="M:DryIoc.Made.Of(DryIoc.FactoryMethod,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Specifies injections rules for Constructor, Parameters, Properties and Fields. If no rules specified returns <see cref="F:DryIoc.Made.Default"/> rules.</summary>
            <param name="factoryMethod">Known factory method.</param>
            <param name="parameters">(optional)</param> <param name="propertiesAndFields">(optional)</param>
            <returns>New injection rules.</returns>
        </member>
        <member name="M:DryIoc.Made.Of(System.Reflection.MemberInfo,DryIoc.ServiceInfo,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Creates rules with only <see cref="P:DryIoc.Made.FactoryMethod"/> specified.</summary>
            <param name="factoryMethodOrMember">To create service.</param>
            <param name="factoryInfo">(optional) Factory info to resolve in case of instance member.</param>
            <param name="parameters">(optional)</param> <param name="propertiesAndFields">(optional)</param>
            <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Made.Of(System.Func{DryIoc.Request,System.Reflection.MemberInfo},DryIoc.ServiceInfo,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Creates factory specification with method or member selector based on request.</summary>
            <param name="getMethodOrMember">Method, or constructor, or member selector.</param>
            <param name="factoryInfo">(optional) Factory info to resolve in case of instance method/member.</param>
            <param name="parameters">(optional)</param> <param name="propertiesAndFields">(optional)</param>
            <returns>New specification.</returns>
        </member>
        <member name="M:DryIoc.Made.Of(System.Func{DryIoc.Request,System.Reflection.MemberInfo},System.Func{DryIoc.Request,DryIoc.ServiceInfo},DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Creates factory specification with method or member selector based on request.</summary>
            <param name="getMethodOrMember">Method, or constructor, or member selector.</param>
            <param name="factoryInfo">Factory info to resolve in case of instance method/member.</param>
            <param name="parameters">(optional)</param> <param name="propertiesAndFields">(optional)</param>
            <returns>New specification.</returns>
        </member>
        <member name="M:DryIoc.Made.Of(System.Func{System.Type,System.Reflection.ConstructorInfo},DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Defines how to select constructor from implementation type.</summary>
            <param name="getConstructor">Delegate taking implementation type as input and returning selected constructor info.</param>
            <param name="parameters">(optional)</param> <param name="propertiesAndFields">(optional)</param>
            <returns>New instance of <see cref="T:DryIoc.Made"/> with <see cref="P:DryIoc.Made.FactoryMethod"/> set to specified delegate.</returns>
        </member>
        <member name="M:DryIoc.Made.Of``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Func{DryIoc.RequestInfo,System.Object}[])">
            <summary>Defines factory method using expression of constructor call (with properties), or static method call.</summary>
            <typeparam name="TService">Type with constructor or static method.</typeparam>
            <param name="serviceReturningExpr">Expression tree with call to constructor with properties:
            <code lang="cs"><![CDATA[() => new Car(Arg.Of<IEngine>()) { Color = Arg.Of<Color>("CarColor") }]]></code>
            or static method call <code lang="cs"><![CDATA[() => Car.Create(Arg.Of<IEngine>())]]></code></param>
            <param name="argValues">(optional) Primitive custom values for dependencies.</param>
            <returns>New Made specification.</returns>
        </member>
        <member name="M:DryIoc.Made.Of``2(System.Func{DryIoc.Request,DryIoc.ServiceInfo.Typed{``0}},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{DryIoc.RequestInfo,System.Object}[])">
            <summary>Defines creation info from factory method call Expression without using strings.
            You can supply any/default arguments to factory method, they won't be used, it is only to find the <see cref="T:System.Reflection.MethodInfo"/>.</summary>
            <typeparam name="TFactory">Factory type.</typeparam> <typeparam name="TService">Factory product type.</typeparam>
            <param name="getFactoryInfo">Returns or resolves factory instance.</param>
            <param name="serviceReturningExpr">Method, property or field expression returning service.</param>
            <param name="argValues">(optional) Primitive custom values for dependencies.</param>
            <returns>New Made specification.</returns>
        </member>
        <member name="T:DryIoc.Made.TypedMade`1">
            <summary>Typed version of <see cref="T:DryIoc.Made"/> specified with statically typed expression tree.</summary>
            <typeparam name="TService">Type that expression returns.</typeparam>
        </member>
        <member name="M:DryIoc.Made.TypedMade`1.#ctor(DryIoc.FactoryMethodSelector,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector,System.Boolean)">
            <summary>Creates typed version.</summary>
            <param name="factoryMethod"></param> <param name="parameters"></param> <param name="propertiesAndFields"></param>
            <param name="hasCustomValue"></param>
        </member>
        <member name="T:DryIoc.Arg">
            <summary>Class for defining parameters/properties/fields service info in <see cref="T:DryIoc.Made"/> expressions.
            Its methods are NOT actually called, they just used to reflect service info from call expression.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1">
            <summary>Specifies required service type of parameter or member. If required type is the same as parameter/member type,
            the method is just a placeholder to help detect constructor or factory method, and does not have additional meaning.</summary>
            <typeparam name="TRequired">Required service type if different from parameter/member type.</typeparam>
            <returns>Returns some (ignored) value.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``2">
            <summary>Specifies both service and required service types.</summary>
            <typeparam name="TService">Service type.</typeparam> <typeparam name="TRequired">Required service type.</typeparam>
            <returns>Ignored default of Service type.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``1(DryIoc.IfUnresolved)">
            <summary>Specifies required service type of parameter or member. Plus specifies if-unresolved policy.</summary>
            <typeparam name="TRequired">Required service type if different from parameter/member type.</typeparam>
            <param name="ifUnresolved">Defines to throw or to return default if unresolved.</param>
            <returns>Returns some (ignored) value.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``2(DryIoc.IfUnresolved)">
            <summary>Specifies both service and required service types.</summary>
            <typeparam name="TService">Service type.</typeparam> <typeparam name="TRequired">Required service type.</typeparam>
            <param name="ifUnresolved">Defines to throw or to return default if unresolved.</param>
            <returns>Ignored default of Service type.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``1(System.Object)">
            <summary>Specifies required service type of parameter or member. Plus specifies service key.</summary>
            <typeparam name="TRequired">Required service type if different from parameter/member type.</typeparam>
            <param name="serviceKey">Service key object.</param>
            <returns>Returns some (ignored) value.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``2(System.Object)">
            <summary>Specifies both service and required service types.</summary>
            <typeparam name="TService">Service type.</typeparam> <typeparam name="TRequired">Required service type.</typeparam>
            <param name="serviceKey">Service key object.</param>
            <returns>Ignored default of Service type.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``1(System.String,System.Object)">
            <summary>Specifies required service type of parameter or member. Plus specifies service key.</summary>
            <typeparam name="TRequired">Required service type if different from parameter/member type.</typeparam>
            <param name="metadataKey">Required metadata key</param> <param name="metadata">Required metadata or value.</param>
            <returns>Returns some (ignored) value.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``2(System.String,System.Object)">
            <summary>Specifies both service and required service types.</summary>
            <typeparam name="TService">Service type.</typeparam> <typeparam name="TRequired">Required service type.</typeparam>
            <param name="metadataKey">Required metadata key</param> <param name="metadata">Required metadata or value.</param>
            <returns>Ignored default of Service type.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``1(DryIoc.IfUnresolved,System.Object)">
            <summary>Specifies required service type of parameter or member. Plus specifies if-unresolved policy. Plus specifies service key.</summary>
            <typeparam name="TRequired">Required service type if different from parameter/member type.</typeparam>
            <param name="ifUnresolved">Defines to throw or to return default if unresolved.</param>
            <param name="serviceKey">Service key object.</param>
            <returns>Returns some (ignored) value.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``2(DryIoc.IfUnresolved,System.Object)">
            <summary>Specifies both service and required service types.</summary>
            <typeparam name="TService">Service type.</typeparam> <typeparam name="TRequired">Required service type.</typeparam>
            <param name="ifUnresolved">Defines to throw or to return default if unresolved.</param>
            <param name="serviceKey">Service key object.</param>
            <returns>Ignored default of Service type.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``1(``0,DryIoc.IfUnresolved)">
            <summary>Specifies required service type, default value and <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</summary>
            <typeparam name="TRequired">Required service type.</typeparam>
            <param name="defaultValue">Primitive default value.</param>
            <param name="ifUnresolved">Only the <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/> value is accepted.</param>
            <returns>Ignored.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``1(``0,DryIoc.IfUnresolved,System.Object)">
            <summary>Specifies required service type, default value and <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</summary>
            <typeparam name="TRequired">Required service type.</typeparam>
            <param name="defaultValue">Primitive default value.</param>
            <param name="ifUnresolved">Only the <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/> value is accepted.</param>
            <param name="serviceKey">Service key object.</param>
            <returns>Ignored.</returns>
        </member>
        <member name="M:DryIoc.Arg.Index``1(System.Int32)">
            <summary>Specifies argument index starting from 0 to use corresponding custom value factory,
            similar to String.Format <c>"{0}, {1}, etc"</c>.</summary>
            <typeparam name="T">Type of dependency. Difference from actual parameter type is ignored.</typeparam>
            <param name="argIndex">Argument index starting from 0</param> <returns>Ignored.</returns>
        </member>
        <member name="F:DryIoc.Arg.ArgIndexMethodName">
            <summary>Name is close to method itself to not forget when renaming the method.</summary>
        </member>
        <member name="T:DryIoc.Registrator">
            <summary>Contains <see cref="T:DryIoc.IRegistrator"/> extension methods to simplify general use cases.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register(DryIoc.IRegistrator,System.Type,DryIoc.Factory,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers service of <paramref name="serviceType"/>.</summary>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="serviceType">The service type to register</param>
            <param name="factory"><see cref="T:DryIoc.Factory"/> details object.</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional Could be of any type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.Register(DryIoc.IRegistrator,System.Type,System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers service <paramref name="serviceType"/> with corresponding <paramref name="implementationType"/>.</summary>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="serviceType">The service type to register.</param>
            <param name="implementationType">Implementation type. Concrete and open-generic class are supported.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>.
                Default value means no reuse, aka Transient.</param>
            <param name="made">(optional) specifies <see cref="T:DryIoc.Made"/>.</param>
            <param name="setup">(optional) Factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) Policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.Register(DryIoc.IRegistrator,System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers service of <paramref name="serviceAndMayBeImplementationType"/>. ServiceType will be the same as <paramref name="serviceAndMayBeImplementationType"/>.</summary>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="serviceAndMayBeImplementationType">Implementation type. Concrete and open-generic class are supported.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="made">(optional) specifies <see cref="T:DryIoc.Made"/>.</param>
            <param name="setup">(optional) factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.Register``2(DryIoc.IRegistrator,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers service of <typeparamref name="TService"/> type implemented by <typeparamref name="TImplementation"/> type.</summary>
            <typeparam name="TService">The type of service.</typeparam>
            <typeparam name="TImplementation">The type of service.</typeparam>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="made">(optional) specifies <see cref="T:DryIoc.Made"/>.</param>
            <param name="setup">(optional) factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.Register``1(DryIoc.IRegistrator,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers implementation type <typeparamref name="TImplementation"/> with itself as service type.</summary>
            <typeparam name="TImplementation">The type of service.</typeparam>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="made">(optional) specifies <see cref="T:DryIoc.Made"/>.</param>
            <param name="setup">(optional) Factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) Policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional) Service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.Register``2(DryIoc.IRegistrator,DryIoc.Made.TypedMade{``1},DryIoc.IReuse,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers service type returned by Made expression.</summary>
            <typeparam name="TService">The type of service.</typeparam>
            <typeparam name="TMadeResult">The type returned by Made expression.</typeparam>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="made">Made specified with strongly-typed service creation expression.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="setup">(optional) Factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) Policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional) Service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.Register``1(DryIoc.IRegistrator,DryIoc.Made.TypedMade{``0},DryIoc.IReuse,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers service type returned by Made expression.</summary>
            <typeparam name="TService">The type of service.</typeparam>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="made">Made specified with strongly-typed service creation expression.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="setup">(optional) Factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) Policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional) Service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="T:DryIoc.Registrator.RegisterManyAction">
            <summary>Action that could be used by User to customize register many default behavior.</summary>
            <param name="r">Registrator provided to do any arbitrary registration User wants.</param>
            <param name="serviceTypes">Valid service type that could be used with <paramref name="implType"/>.</param>
            <param name="implType">Concrete or open-generic implementation type.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Type[],System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers many service types with the same implementation.</summary>
            <param name="registrator">Registrator/Container</param>
            <param name="serviceTypes">1 or more service types.</param>
            <param name="implementationType">Should implement service types. Will throw if not.</param>
            <param name="reuse">(optional)</param> <param name="made">(optional) How to create implementation instance.</param>
            <param name="setup">(optional)</param> <param name="ifAlreadyRegistered">(optional) By default <see cref="F:DryIoc.IfAlreadyRegistered.AppendNotKeyed"/></param>
            <param name="serviceKey">(optional)</param>
        </member>
        <member name="F:DryIoc.Registrator.ExcludedGeneralPurposeServiceTypes">
            <summary>List of types excluded by default from RegisterMany convention.</summary>
        </member>
        <member name="M:DryIoc.Registrator.IsExcludedGeneralPurposeServiceType(System.Type)">
            <summary>Checks that type is not in the list of <see cref="F:DryIoc.Registrator.ExcludedGeneralPurposeServiceTypes"/>.</summary>
            <param name="type">Type to check</param> <returns>True if not in the list.</returns>
        </member>
        <member name="M:DryIoc.Registrator.GetImplementedServiceTypes(System.Type,System.Boolean)">
            <summary>Returns only those types that could be used as service types of <paramref name="type"/>. It means that
            for open-generic <paramref name="type"/> its service type should supply all type arguments.</summary>
            <param name="type">Source type: may be concrete, abstract or generic definition.</param>
            <param name="nonPublicServiceTypes">(optional) Include non public service types.</param>
            <returns>Array of types or empty.</returns>
        </member>
        <member name="M:DryIoc.Registrator.GetRegisterManyImplementedServiceTypes(System.Type,System.Boolean)">
            <summary>Returns the sensible services automatically discovered for RegisterMany implementation type.
            Excludes the collection wrapper interfaces.</summary>
            <param name="type">Source type, may be concrete, abstract or generic definition.</param>
            <param name="nonPublicServiceTypes">(optional) Include non public service types.</param>
            <returns>Array of types or empty.</returns>
        </member>
        <member name="M:DryIoc.Registrator.GetImplementationTypes(System.Reflection.Assembly)">
            <summary>Returns the types suitable to be an implementation types for <see cref="T:DryIoc.ReflectionFactory"/>:
            actually a non abstract and not compiler generated classes.</summary>
            <param name="assembly">Assembly to get types from.</param>
            <returns>Types.</returns>
        </member>
        <member name="M:DryIoc.Registrator.IsImplementationType(System.Type)">
            <summary>Checks if type can be used as implementation type for reflection factory,
            and therefore registered to container. Usually used to discover implementation types from assembly.</summary>
            <param name="type">Type to check.</param> <returns>True if implementation type.</returns>
        </member>
        <member name="M:DryIoc.Registrator.ImplementsServiceType(System.Type,System.Type,System.Boolean)">
            <summary>Checks if <paramref name="type"/> implements the <paramref name="serviceType"/>,
            along the line checking if <paramref name="type"/> and <paramref name="serviceType"/>
            are valid implementation and service types.</summary>
            <param name="type">Implementation type.</param>
            <param name="serviceType">Service type.</param>
            <param name="checkIfOpenGenericImplementsClosedGeneric">(optional)</param>
            <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Type},DryIoc.Registrator.RegisterManyAction,System.Boolean)">
            <summary>Registers many implementations with the auto-figured service types.</summary>
            <param name="registrator">Registrator/Container to register with.</param>
            <param name="implTypes">Implementation type provider.</param>
            <param name="action">(optional) User specified registration action:
            may be used to filter registrations or specify non-default registration options, e.g. Reuse or ServiceKey, etc.</param>
            <param name="nonPublicServiceTypes">(optional) Include non public service types.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Type},DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Func{System.Type,System.Boolean},System.Boolean,System.Object)">
            <summary>Registers many implementations with their auto-figured service types.</summary>
            <param name="registrator">Registrator/Container to register with.</param>
            <param name="implTypes">Implementation type provider.</param>
            <param name="reuse">(optional) Reuse to apply to all service registrations.</param>
            <param name="made">(optional) Allow to select constructor/method to create service, specify how to inject its parameters and properties/fields.</param>
            <param name="setup">(optional) Factory setup, by default is <see cref="F:DryIoc.Setup.Default"/>, check <see cref="T:DryIoc.Setup"/> class for available setups.</param>
            <param name="ifAlreadyRegistered">(optional) Policy to deal with existing service registrations.</param>
            <param name="serviceTypeCondition">(optional) Condition to select only specific service type to register.</param>
            <param name="nonPublicServiceTypes">(optional) Include non public service types.</param>
            <param name="serviceKey">(optional) service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany``1(DryIoc.IRegistrator,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Func{System.Type,System.Boolean},System.Boolean,System.Object)">
            <summary>Registers single registration for all implemented public interfaces and base classes.</summary>
            <typeparam name="TImplementation">The type to get service types from.</typeparam>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="made">(optional) Allow to select constructor/method to create service, specify how to inject its parameters and properties/fields.</param>
            <param name="setup">(optional) Factory setup, by default is <see cref="F:DryIoc.Setup.Default"/>, check <see cref="T:DryIoc.Setup"/> class for available setups.</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceTypeCondition">(optional) Condition to select only specific service type to register.</param>
            <param name="nonPublicServiceTypes">(optional) Include non public service types.</param>
            <param name="serviceKey">(optional) service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany``1(DryIoc.IRegistrator,DryIoc.Made.TypedMade{``0},DryIoc.IReuse,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Func{System.Type,System.Boolean},System.Boolean,System.Object)">
            <summary>Registers single registration for all implemented public interfaces and base classes.</summary>
            <typeparam name="TMadeResult">The type returned by Made factory expression.</typeparam>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="made">Made specified with strongly-typed factory expression.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="setup">(optional) Factory setup, by default is <see cref="F:DryIoc.Setup.Default"/>, check <see cref="T:DryIoc.Setup"/> class for available setups.</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceTypeCondition">(optional) Condition to select only specific service type to register.</param>
            <param name="nonPublicServiceTypes">(optional) Include non public service types.</param>
            <param name="serviceKey">(optional) service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},DryIoc.Registrator.RegisterManyAction,System.Boolean)">
            <summary>Registers many implementations with their auto-figured service types.</summary>
            <param name="registrator">Registrator/Container to register with.</param>
            <param name="implTypeAssemblies">Assemblies with implementation/service types to register.</param>
            <param name="action">(optional) User specified registration action:
            may be used to filter registrations or specify non-default registration options, e.g. Reuse or ServiceKey, etc..</param>
            <param name="nonPublicServiceTypes">(optional) Include non public service types.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Func{System.Type,System.Boolean},DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Boolean,System.Object)">
            <summary>Registers many implementations with their auto-figured service types.</summary>
            <param name="registrator">Registrator/Container to register with.</param>
            <param name="implTypeAssemblies">Assemblies with implementation/service types to register.</param>
            <param name="serviceTypeCondition">Condition to select only specific service type to register.</param>
            <param name="reuse">(optional) Reuse to apply to all service registrations.</param>
            <param name="made">(optional) Allow to select constructor/method to create service, specify how to inject its parameters and properties/fields.</param>
            <param name="setup">(optional) Factory setup, by default is <see cref="F:DryIoc.Setup.Default"/>, check <see cref="T:DryIoc.Setup"/> class for available setups.</param>
            <param name="ifAlreadyRegistered">(optional) Policy to deal with existing service registrations.</param>
            <param name="nonPublicServiceTypes">(optional) Include non public service types.</param>
            <param name="serviceKey">(optional) service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``1(DryIoc.IRegistrator,System.Func{DryIoc.IResolver,``0},DryIoc.IReuse,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers a factory delegate for creating an instance of <typeparamref name="TService"/>.
            Delegate can use <see cref="T:DryIoc.IResolver"/> parameter to resolve any required dependencies, e.g.:
            <code lang="cs"><![CDATA[container.RegisterDelegate<ICar>(r => new Car(r.Resolve<IEngine>()))]]></code></summary>
            <typeparam name="TService">The type of service.</typeparam>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="factoryDelegate">The delegate used to create a instance of <typeparamref name="TService"/>.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="setup">(optional) factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
            <remarks>IMPORTANT: The method should be used as the last resort only! Though powerful it is a black-box for container,
            which prevents diagnostics, plus it is easy to get memory leaks (due variables captured in delegate closure),
            and impossible to use in compile-time scenarios.
            Consider using <see cref="T:DryIoc.Made"/> instead:
            <code lang="cs"><![CDATA[container.Register<ICar>(Made.Of(() => new Car(Arg.Of<IEngine>())))]]></code>.
            </remarks>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate(DryIoc.IRegistrator,System.Type,System.Func{DryIoc.IResolver,System.Object},DryIoc.IReuse,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers a factory delegate for creating an instance of <paramref name="serviceType"/>.
            Delegate can use <see cref="T:DryIoc.IResolver"/> parameter to resolve any required dependencies, e.g.:
            <code lang="cs"><![CDATA[container.RegisterDelegate<ICar>(r => new Car(r.Resolve<IEngine>()))]]></code></summary>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="serviceType">Service type to register.</param>
            <param name="factoryDelegate">The delegate used to create a instance of <paramref name="serviceType"/>.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="setup">(optional) factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
            <remarks>IMPORTANT: The method should be used as the last resort only! Though powerful it is a black-box for container,
            which prevents diagnostics, plus it is easy to get memory leaks (due variables captured in delegate closure),
            and impossible to use in compile-time scenarios.
            Consider using <see cref="T:DryIoc.Made"/> instead:
            <code lang="cs"><![CDATA[container.Register<ICar>(Made.Of(() => new Car(Arg.Of<IEngine>())))]]></code>.
            </remarks>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegateDecorator``1(DryIoc.IRegistrator,System.Func{DryIoc.IResolver,System.Func{``0,``0}},System.Func{DryIoc.RequestInfo,System.Boolean})">
            <summary>Registers decorator function that gets decorated value as input and returns decorator.
            Note: Delegate decorator will use <see cref="T:DryIoc.Reuse"/> of decoratee service.</summary>
            <typeparam name="TService">Registered service type to decorate.</typeparam>
            <param name="registrator">Registrator/Container.</param>
            <param name="getDecorator">Delegate returning decorating function.</param>
            <param name="condition">(optional) Condition for decorator application.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInstance(DryIoc.IContainer,System.Type,System.Object,DryIoc.IReuse,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            <summary>Obsolete: replaced with UseInstance</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInstance``1(DryIoc.IContainer,``0,DryIoc.IReuse,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            <summary>Obsolete: replaced with UseInstance</summary>
        </member>
        <member name="M:DryIoc.Registrator.UseInstance``1(DryIoc.IContainer,``0,System.Boolean,System.Boolean,System.Object)">
            <summary>Stores the externally created instance into open scope or singleton,
            replacing the existing registration and instance if any.</summary>
            <typeparam name="TService">Specified instance type. May be a base type or interface of instance actual type.</typeparam>
            <param name="container">Container to register</param>
            <param name="instance">Instance to register</param>
            <param name="preventDisposal">(optional) Prevents disposing of disposable instance by container.</param>
            <param name="weaklyReferenced">(optional)Stores the weak reference to instance, allowing to GC it.</param>
            <param name="serviceKey">(optional) Service key to identify instance from many.</param>
        </member>
        <member name="M:DryIoc.Registrator.UseInstance(DryIoc.IContainer,System.Type,System.Object,System.Boolean,System.Boolean,System.Object)">
            <summary>Stores the externally created instance into open scope or singleton,
            replacing the existing registration and instance if any.</summary>
            <param name="container">Container to register</param>
            <param name="serviceType">Runtime service type to register instance with</param>
            <param name="instance">Instance to register</param>
            <param name="preventDisposal">(optional) Prevents disposing of disposable instance by container.</param>
            <param name="weaklyReferenced">(optional)Stores the weak reference to instance, allowing to GC it.</param>
            <param name="serviceKey">(optional) Service key to identify instance from many.</param>
        </member>
        <member name="M:DryIoc.Registrator.UseInstance``1(DryIoc.IContainer,``0,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            <summary>Stores the externally created instance into open scope or singleton,
            replacing the existing registration and instance if any.</summary>
            <typeparam name="TService">Specified instance type. May be a base type or interface of instance actual type.</typeparam>
            <param name="container">Container to register</param>
            <param name="instance">Instance to register</param>
            <param name="IfAlreadyRegistered">The default is <see cref="F:DryIoc.IfAlreadyRegistered.Replace"/>.</param>
            <param name="preventDisposal">(optional) Prevents disposing of disposable instance by container.</param>
            <param name="weaklyReferenced">(optional)Stores the weak reference to instance, allowing to GC it.</param>
            <param name="serviceKey">(optional) Service key to identify instance from many.</param>
        </member>
        <member name="M:DryIoc.Registrator.UseInstance(DryIoc.IContainer,System.Type,System.Object,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            <summary>Stores the externally created instance into open scope or singleton,
            replacing the existing registration and instance if any.</summary>
            <param name="container">Container to register</param>
            <param name="serviceType">Runtime service type to register instance with</param>
            <param name="instance">Instance to register</param>
            <param name="IfAlreadyRegistered">The default is <see cref="F:DryIoc.IfAlreadyRegistered.Replace"/>.</param>
            <param name="preventDisposal">(optional) Prevents disposing of disposable instance by container.</param>
            <param name="weaklyReferenced">(optional)Stores the weak reference to instance, allowing to GC it.</param>
            <param name="serviceKey">(optional) Service key to identify instance from many.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInitializer``1(DryIoc.IRegistrator,System.Action{``0,DryIoc.IResolver},System.Func{DryIoc.RequestInfo,System.Boolean})">
            <summary>Registers initializing action that will be called after service is resolved 
            just before returning it to the caller.  You can register multiple initializers for single service.
            Or you can register initializer for <see cref="T:System.Object"/> type to be applied 
            for all services and use <paramref name="condition"/> to specify the target services.</summary>
            <typeparam name="TTarget">Any type implemented by requested service type including service type itself and object type.</typeparam>
            <param name="registrator">Usually is <see cref="T:DryIoc.Container"/> object.</param>
            <param name="initialize">Delegate with <typeparamref name="TTarget"/> object and
            <see cref="T:DryIoc.IResolver"/> to resolve additional services required by initializer.</param>
            <param name="condition">(optional) Additional condition to select required target.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDisposer``1(DryIoc.IRegistrator,System.Action{``0},System.Func{DryIoc.RequestInfo,System.Boolean})">
            <summary>Registers dispose action for reused target service.</summary>
            <typeparam name="TService">Target service type.</typeparam>
            <param name="registrator">Registrator to use.</param>
            <param name="dispose">Actual dispose action to be invoke when scope is disposed.</param>
            <param name="condition">(optional) Additional way to identify the service.</param>
        </member>
        <member name="M:DryIoc.Registrator.IsRegistered(DryIoc.IRegistrator,System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Returns true if <paramref name="serviceType"/> is registered in container or its open generic definition is registered in container.</summary>
            <param name="registrator">Usually <see cref="T:DryIoc.Container"/> to explore or any other <see cref="T:DryIoc.IRegistrator"/> implementation.</param>
            <param name="serviceType">The type of the registered service.</param>
            <param name="serviceKey">(optional) Identifies registration via service key.
            Not provided or <c>null</c> service key means to check the <paramref name="serviceType"/> alone with any service key.</param>
            <param name="factoryType">(optional) factory type to lookup, <see cref="F:DryIoc.FactoryType.Service"/> by default.</param>
            <param name="condition">(optional) condition to specify what registered factory do you expect.</param>
            <returns>True if <paramref name="serviceType"/> is registered, false - otherwise.</returns>
        </member>
        <member name="M:DryIoc.Registrator.IsRegistered``1(DryIoc.IRegistrator,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Returns true if <typeparamref name="TService"/> type is registered in container or its open generic definition is registered in container.</summary>
            <typeparam name="TService">The type of service.</typeparam>
            <param name="registrator">Usually <see cref="T:DryIoc.Container"/> to explore or any other <see cref="T:DryIoc.IRegistrator"/> implementation.</param>
            <param name="serviceKey">(optional) Identifies registration via service key.
            Not provided or <c>null</c> service key means to check the <typeparamref name="TService"/> alone with any service key.</param>
            <param name="factoryType">(optional) factory type to lookup, <see cref="F:DryIoc.FactoryType.Service"/> by default.</param>
            <param name="condition">(optional) condition to specify what registered factory do you expect.</param>
            <returns>True if <typeparamref name="TService"/> name="serviceType"/> is registered, false - otherwise.</returns>
        </member>
        <member name="M:DryIoc.Registrator.Unregister(DryIoc.IRegistrator,System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Removes specified registration from container.</summary>
            <param name="registrator">Usually <see cref="T:DryIoc.Container"/> to explore or any other <see cref="T:DryIoc.IRegistrator"/> implementation.</param>
            <param name="serviceType">Type of service to remove.</param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
            <param name="factoryType">(optional) Factory type to lookup, <see cref="F:DryIoc.FactoryType.Service"/> by default.</param>
            <param name="condition">(optional) Condition for Factory to be removed.</param>
        </member>
        <member name="M:DryIoc.Registrator.Unregister``1(DryIoc.IRegistrator,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Removes specified registration from container.</summary>
            <typeparam name="TService">The type of service to remove.</typeparam>
            <param name="registrator">Usually <see cref="T:DryIoc.Container"/> or any other <see cref="T:DryIoc.IRegistrator"/> implementation.</param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
            <param name="factoryType">(optional) Factory type to lookup, <see cref="F:DryIoc.FactoryType.Service"/> by default.</param>
            <param name="condition">(optional) Condition for Factory to be removed.</param>
        </member>
        <member name="T:DryIoc.Resolver">
            <summary>Defines convenient extension methods for <see cref="T:DryIoc.IResolver"/>.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type)">
            <summary>Returns instance of <typepsaramref name="TService"/> type.</summary>
            <param name="serviceType">The type of the requested service.</param>
            <param name="resolver">Any <see cref="T:DryIoc.IResolver"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <returns>The requested service instance.</returns>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type,DryIoc.IfUnresolved)">
            <summary>Returns instance of <typepsaramref name="TService"/> type.</summary>
            <param name="serviceType">The type of the requested service.</param>
            <param name="resolver">Any <see cref="T:DryIoc.IResolver"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="ifUnresolved">Says how to handle unresolved service.</param>
            <returns>The requested service instance.</returns>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,DryIoc.IfUnresolved)">
            <summary>Returns instance of <typepsaramref name="TService"/> type.</summary>
            <typeparam name="TService">The type of the requested service.</typeparam>
            <param name="resolver">Any <see cref="T:DryIoc.IResolver"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="ifUnresolved">(optional) Says how to handle unresolved service.</param>
            <returns>The requested service instance.</returns>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,System.Type,DryIoc.IfUnresolved)">
            <summary>Returns instance of <typeparamref name="TService"/> searching for <paramref name="requiredServiceType"/>.
            In case of <typeparamref name="TService"/> being generic wrapper like Func, Lazy, IEnumerable, etc., <paramref name="requiredServiceType"/>
            could specify wrapped service type.</summary>
            <typeparam name="TService">The type of the requested service.</typeparam>
            <param name="resolver">Any <see cref="T:DryIoc.IResolver"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="requiredServiceType">(optional) Service or wrapped type assignable to <typeparamref name="TService"/>.</param>
            <param name="ifUnresolved">(optional) Says how to handle unresolved service.</param>
            <returns>The requested service instance.</returns>
            <remarks>Using <paramref name="requiredServiceType"/> implicitly support Covariance for generic wrappers even in .Net 3.5.</remarks>
            <example><code lang="cs"><![CDATA[
                container.Register<IService, Service>();
                var services = container.Resolve<IEnumerable<object>>(typeof(IService));
            ]]></code></example>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type,System.Object,DryIoc.IfUnresolved,System.Type)">
            <summary>Returns instance of <paramref name="serviceType"/> searching for <paramref name="requiredServiceType"/>.
            In case of <paramref name="serviceType"/> being generic wrapper like Func, Lazy, IEnumerable, etc., <paramref name="requiredServiceType"/>
            could specify wrapped service type.</summary>
            <param name="serviceType">The type of the requested service.</param>
            <param name="resolver">Any <see cref="T:DryIoc.IResolver"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="serviceKey">Service key (any type with <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/> defined).</param>
            <param name="ifUnresolved">(optional) Says how to handle unresolved service.</param>
            <param name="requiredServiceType">(optional) Service or wrapped type assignable to <paramref name="serviceType"/>.</param>
            <returns>The requested service instance.</returns>
            <remarks>Using <paramref name="requiredServiceType"/> implicitly support Covariance for generic wrappers even in .Net 3.5.</remarks>
            <example><code lang="cs"><![CDATA[
                container.Register<IService, Service>();
                var services = container.Resolve(typeof(Lazy<object>), "someKey", requiredServiceType: typeof(IService));
            ]]></code></example>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,System.Object,DryIoc.IfUnresolved,System.Type)">
            <summary>Returns instance of <typepsaramref name="TService"/> type.</summary>
            <typeparam name="TService">The type of the requested service.</typeparam>
            <param name="resolver">Any <see cref="T:DryIoc.IResolver"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="serviceKey">Service key (any type with <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/> defined).</param>
            <param name="ifUnresolved">(optional) Says how to handle unresolved service.</param>
            <param name="requiredServiceType">(optional) Service or wrapped type assignable to <typeparamref name="TService"/>.</param>
            <returns>The requested service instance.</returns>
            <remarks>Using <paramref name="requiredServiceType"/> implicitly support Covariance for generic wrappers even in .Net 3.5.</remarks>
        </member>
        <member name="M:DryIoc.Resolver.ResolveMany``1(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object)">
            <summary>Returns all registered services instances including all keyed and default registrations.
            Use <paramref name="behavior"/> to return either all registered services at the moment of resolve (dynamic fresh view) or
            the same services that were returned with first <see cref="M:DryIoc.Resolver.ResolveMany``1(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object)"/> call (fixed view).</summary>
            <typeparam name="TService">Return collection item type. It denotes registered service type if <paramref name="requiredServiceType"/> is not specified.</typeparam>
            <param name="resolver">Usually <see cref="T:DryIoc.Container"/> object.</param>
            <param name="requiredServiceType">(optional) Denotes registered service type. Should be assignable to <typeparamref name="TService"/>.</param>
            <param name="behavior">(optional) Specifies new registered services awareness. Aware by default.</param>
            <param name="serviceKey">(optional) Service key.</param>
            <returns>Result collection of services.</returns>
            <remarks>The same result could be achieved by directly calling:
            <code lang="cs"><![CDATA[
                container.Resolve<LazyEnumerable<IService>>();  // for dynamic result - default behavior
                container.Resolve<IService[]>();                // for fixed array
                container.Resolve<IEnumerable<IService>>();     // same as fixed array
            ]]></code>
            </remarks>
        </member>
        <member name="M:DryIoc.Resolver.ResolveMany(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object)">
            <summary>Returns all registered services as objects, including all keyed and default registrations.</summary>
            <param name="resolver">Usually <see cref="T:DryIoc.Container"/> object.</param>
            <param name="serviceType">Type of item to resolve.</param>
            <param name="behavior">(optional) Specifies new registered services awareness. Aware by default.</param>
            <param name="serviceKey">(optional) Service key.</param>
            <returns>Result collection of services.</returns>
            <returns></returns>
        </member>
        <member name="T:DryIoc.ResolveManyBehavior">
            <summary>Specifies result of <see cref="M:DryIoc.Resolver.ResolveMany``1(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object)"/>: either dynamic(lazy) or fixed view.</summary>
        </member>
        <member name="F:DryIoc.ResolveManyBehavior.AsLazyEnumerable">
            <summary>Lazy/dynamic item resolve.</summary>
        </member>
        <member name="F:DryIoc.ResolveManyBehavior.AsFixedArray">
            <summary>Fixed array of item at time of resolve, newly registered/removed services won't be listed.</summary>
        </member>
        <member name="T:DryIoc.IServiceInfo">
            <summary>Provides information required for service resolution: service type,
            and optional <see cref="T:DryIoc.ServiceDetails"/>: key, what to do if service unresolved, and required service type.</summary>
        </member>
        <member name="P:DryIoc.IServiceInfo.ServiceType">
            <summary>The required piece of info: service type.</summary>
        </member>
        <member name="P:DryIoc.IServiceInfo.Details">
            <summary>Additional optional details: service key, if-unresolved policy, required service type.</summary>
        </member>
        <member name="M:DryIoc.IServiceInfo.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
            <param name="serviceType">Required service type.</param> <param name="details">Optional details.</param> <returns>Create info.</returns>
        </member>
        <member name="T:DryIoc.ServiceDetails">
            <summary>Provides optional service resolution details: service key, required service type, what return when service is unresolved,
            default value if service is unresolved, custom service value.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.Default">
            <summary>Default details if not specified, use default setting values, e.g. <see cref="F:DryIoc.IfUnresolved.Throw"/></summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.IfUnresolvedReturnDefault">
            <summary>The same as <see cref="F:DryIoc.ServiceDetails.Default"/> with only difference <see cref="F:DryIoc.ServiceDetails.IfUnresolved"/> set to <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</summary>
        </member>
        <member name="M:DryIoc.ServiceDetails.Of(System.Type,System.Object,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Creates new details out of provided settings, or returns default if all settings have default value.</summary>
            <param name="requiredServiceType">Registered service type to search for.</param>
            <param name="serviceKey">Service key.</param> <param name="ifUnresolved">If unresolved policy.</param>
            <param name="defaultValue">Custom default value, if specified it will automatically set <paramref name="ifUnresolved"/> to <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</param>
            <param name="metadataKey">(optional) Required metadata key</param> <param name="metadata">Required metadata or the value if key passed.</param>
            <returns>New details.</returns>
        </member>
        <member name="M:DryIoc.ServiceDetails.Of(System.Object)">
            <summary>Sets custom value for service. This setting is orthogonal to the rest.</summary>
            <param name="value">Custom value.</param> <returns>Details with custom value.</returns>
        </member>
        <member name="F:DryIoc.ServiceDetails.RequiredServiceType">
            <summary>Service type to search in registry. Should be assignable to user requested service type.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.ServiceKey">
            <summary>Service key provided with registration.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.MetadataKey">
            <summary>Metadata key to find in metadata dictionary in resolved service.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.Metadata">
            <summary>Metadata value to find in resolved service.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.IfUnresolved">
            <summary>Policy to deal with unresolved request.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.HasCustomValue">
            <summary>Indicates that the custom value is specified.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails._value">
            <summary>Either default or custom value depending on <see cref="F:DryIoc.ServiceDetails.IfUnresolved"/> setting.</summary>
        </member>
        <member name="P:DryIoc.ServiceDetails.DefaultValue">
            <summary>Value to use in case <see cref="F:DryIoc.ServiceDetails.IfUnresolved"/> is set to <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</summary>
        </member>
        <member name="P:DryIoc.ServiceDetails.CustomValue">
            <summary>Custom value specified for dependency.</summary>
        </member>
        <member name="M:DryIoc.ServiceDetails.ToString">
            <summary>Pretty prints service details to string for debugging and errors.</summary> <returns>Details string.</returns>
        </member>
        <member name="T:DryIoc.ServiceInfoTools">
            <summary>Contains tools for combining or propagating of <see cref="T:DryIoc.IServiceInfo"/> independent of its concrete implementations.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.With(DryIoc.IServiceInfo,System.Type)">
            <summary>Creates service info with new type but keeping the details.</summary>
            <param name="source">Source info.</param> <param name="serviceType">New service type.</param>
            <returns>New info.</returns>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.WithIfUnresolved(DryIoc.IServiceInfo,DryIoc.IfUnresolved)">
            <summary>Creates new info with new IfUnresolved behavior or returns the original info if behavior is not different,
            or the passed info is not a <see cref="F:DryIoc.ServiceDetails.HasCustomValue"/>.</summary>
            <param name="source">Registered service type to search for.</param>
            <param name="ifUnresolved">New If unresolved behavior.</param>
            <returns>New info if the new details are different from the old one, and original info otherwise.</returns>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.WithDetails``1(``0,DryIoc.ServiceDetails,DryIoc.Request)">
            <summary>Combines service info with details: the main task is to combine service and required service type.</summary>
            <typeparam name="T">Type of <see cref="T:DryIoc.IServiceInfo"/>.</typeparam>
            <param name="serviceInfo">Source info.</param> <param name="details">Details to combine with info.</param>
            <param name="request">Owner request.</param> <returns>Original source or new combined info.</returns>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.InheritInfoFromDependencyOwner(DryIoc.IServiceInfo,DryIoc.IServiceInfo,System.Boolean,DryIoc.FactoryType,DryIoc.IContainer)">
            <summary>Enables propagation/inheritance of info between dependency and its owner:
            for instance <see cref="F:DryIoc.ServiceDetails.RequiredServiceType"/> for wrappers.</summary>
            <param name="dependency">Dependency info.</param>
            <param name="owner">Dependency holder/owner info.</param>
            <param name="shouldInheritServiceKey">(optional) to be removed</param>
            <param name="ownerType">(optional)to be removed</param>
            <param name="container">required for <see cref="M:DryIoc.IContainer.GetWrappedType(System.Type,System.Type)"/></param>
            <returns>Either input dependency info, or new info with properties inherited from the owner.</returns>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.GetActualServiceType(DryIoc.IServiceInfo)">
            <summary>Returns required service type if it is specified and assignable to service type,
            otherwise returns service type.</summary>
            <returns>The type to be used for lookup in registry.</returns>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.Print(System.Text.StringBuilder,DryIoc.IServiceInfo)">
            <summary>Appends info string representation into provided builder.</summary>
            <param name="s">String builder to print to.</param> <param name="info">Info to print.</param>
            <returns>String builder with appended info.</returns>
        </member>
        <member name="T:DryIoc.ServiceInfo">
            <summary>Represents custom or resolution root service info, there is separate representation for parameter,
            property and field dependencies.</summary>
        </member>
        <member name="F:DryIoc.ServiceInfo.Empty">
            <summary>Empty service info for convenience.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.Of(System.Type,DryIoc.IfUnresolved,System.Object)">
            <summary>Creates info out of provided settings</summary>
            <param name="serviceType">Service type</param>
            <param name="ifUnresolved">(optional) If unresolved policy. Set to Throw if not specified.</param>
             <param name="serviceKey">(optional) Service key.</param>
            <returns>Created info.</returns>
        </member>
        <member name="M:DryIoc.ServiceInfo.Of(System.Type,System.Type,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Creates info out of provided settings</summary>
            <param name="serviceType">Service type</param>
            <param name="requiredServiceType">Registered service type to search for.</param>
            <param name="ifUnresolved">(optional) If unresolved policy. Set to Throw if not specified.</param>
            <param name="serviceKey">(optional) Service key.</param>
            <param name="metadataKey">(optional) Required metadata key</param>
            <param name="metadata">Required metadata or the value if key passed.</param>
            <returns>Created info.</returns>
        </member>
        <member name="M:DryIoc.ServiceInfo.Of``1(DryIoc.IfUnresolved,System.Object)">
            <summary>Creates service info using typed <typeparamref name="TService"/>.</summary>
            <typeparam name="TService">Service type.</typeparam>
            <param name="ifUnresolved">(optional)</param> <param name="serviceKey">(optional)</param>
            <returns>Created info.</returns>
        </member>
        <member name="T:DryIoc.ServiceInfo.Typed`1">
            <summary>Strongly-typed version of Service Info.</summary> <typeparam name="TService">Service type.</typeparam>
        </member>
        <member name="M:DryIoc.ServiceInfo.Typed`1.#ctor">
            <summary>Creates service info object.</summary>
        </member>
        <member name="P:DryIoc.ServiceInfo.ServiceType">
            <summary>Type of service to create. Indicates registered service in registry.</summary>
        </member>
        <member name="P:DryIoc.ServiceInfo.Details">
            <summary>Additional settings. If not specified uses <see cref="F:DryIoc.ServiceDetails.Default"/>.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
            <param name="serviceType">Required service type.</param> <param name="details">Optional details.</param> <returns>Create info.</returns>
        </member>
        <member name="M:DryIoc.ServiceInfo.ToString">
            <summary>Prints info to string using <see cref="M:DryIoc.ServiceInfoTools.Print(System.Text.StringBuilder,DryIoc.IServiceInfo)"/>.</summary> <returns>Printed string.</returns>
        </member>
        <member name="T:DryIoc.ParameterServiceInfo">
            <summary>Provides <see cref="T:DryIoc.IServiceInfo"/> for parameter,
            by default using parameter name as <see cref="P:DryIoc.IServiceInfo.ServiceType"/>.</summary>
            <remarks>For parameter default setting <see cref="F:DryIoc.ServiceDetails.IfUnresolved"/> is <see cref="F:DryIoc.IfUnresolved.Throw"/>.</remarks>
        </member>
        <member name="M:DryIoc.ParameterServiceInfo.Of(System.Reflection.ParameterInfo)">
            <summary>Creates service info from parameter alone, setting service type to parameter type,
            and setting resolution policy to <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/> if parameter is optional.</summary>
            <param name="parameter">Parameter to create info for.</param>
            <returns>Parameter service info.</returns>
        </member>
        <member name="P:DryIoc.ParameterServiceInfo.ServiceType">
            <summary>Service type specified by <see cref="P:System.Reflection.ParameterInfo.ParameterType"/>.</summary>
        </member>
        <member name="P:DryIoc.ParameterServiceInfo.Details">
            <summary>Optional service details.</summary>
        </member>
        <member name="M:DryIoc.ParameterServiceInfo.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
            <param name="serviceType">Required service type.</param> <param name="details">Optional details.</param> <returns>Create info.</returns>
        </member>
        <member name="F:DryIoc.ParameterServiceInfo.Parameter">
            <summary>Parameter info.</summary>
        </member>
        <member name="M:DryIoc.ParameterServiceInfo.ToString">
            <summary>Prints info to string using <see cref="M:DryIoc.ServiceInfoTools.Print(System.Text.StringBuilder,DryIoc.IServiceInfo)"/>.</summary> <returns>Printed string.</returns>
        </member>
        <member name="T:DryIoc.PropertyOrFieldServiceInfo">
            <summary>Base class for property and field dependency info.</summary>
        </member>
        <member name="M:DryIoc.PropertyOrFieldServiceInfo.Of(System.Reflection.MemberInfo)">
            <summary>Create member info out of provide property or field.</summary>
            <param name="member">Member is either property or field.</param> <returns>Created info.</returns>
        </member>
        <member name="P:DryIoc.PropertyOrFieldServiceInfo.ServiceType">
            <summary>The required service type. It will be either <see cref="P:System.Reflection.FieldInfo.FieldType"/> or <see cref="P:System.Reflection.PropertyInfo.PropertyType"/>.</summary>
        </member>
        <member name="P:DryIoc.PropertyOrFieldServiceInfo.Details">
            <summary>Optional details: service key, if-unresolved policy, required service type.</summary>
        </member>
        <member name="M:DryIoc.PropertyOrFieldServiceInfo.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
            <param name="serviceType">Required service type.</param> <param name="details">Optional details.</param> <returns>Create info.</returns>
        </member>
        <member name="P:DryIoc.PropertyOrFieldServiceInfo.Member">
            <summary>Either <see cref="T:System.Reflection.PropertyInfo"/> or <see cref="T:System.Reflection.FieldInfo"/>.</summary>
        </member>
        <member name="M:DryIoc.PropertyOrFieldServiceInfo.SetValue(System.Object,System.Object)">
            <summary>Sets property or field value on provided holder object.</summary>
            <param name="holder">Holder of property or field.</param> <param name="value">Value to set.</param>
        </member>
        <member name="T:DryIoc.RequestFlags">
            <summary>Stored check results of two kinds: inherited down dependency chain and not.</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.TracksTransientDisposable">
            <summary>Not inherited</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.IsServiceCollection">
            <summary>Not inherited</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.IsSingletonOrDependencyOfSingleton">
            <summary>Inherited</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.IsWrappedInFunc">
            <summary>Inherited</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.IsWrappedInFuncWithArgs">
            <summary>Inherited</summary>
        </member>
        <member name="T:DryIoc.Request">
            <summary>Contains resolution stack with information about resolved service and factory for it,
            Additionally request contain weak reference to <see cref="T:DryIoc.IContainer"/>. That the all required information for resolving services.
            Request implements <see cref="T:DryIoc.IResolver"/> interface on top of provided container, which could be use by delegate factories.</summary>
        </member>
        <member name="F:DryIoc.Request.NotInheritedFlags">
            <summary>Not inherited down dependency chain.</summary>
        </member>
        <member name="M:DryIoc.Request.CreateEmpty(DryIoc.Container)">
            <summary>Obsolete: replaced with <see cref="M:DryIoc.Request.Create(DryIoc.IContainer,System.Type,System.Object,DryIoc.IfUnresolved,System.Type,DryIoc.IScope,DryIoc.RequestInfo)"/>/.</summary>
        </member>
        <member name="M:DryIoc.Request.Create(DryIoc.IContainer,System.Type,System.Object,DryIoc.IfUnresolved,System.Type,DryIoc.IScope,DryIoc.RequestInfo)">
            <summary>Creates empty request associated with container.
            The shared part of request is stored in request context. Pre-request info is also store once in shared context.</summary>
            <param name="container">Associated container - part of request context.</param>
            <param name="serviceType">Service type to resolve.</param>
            <param name="serviceKey">(optional) Service key to resolve.</param>
            <param name="ifUnresolved">(optional) How to handle unresolved service.</param>
            <param name="requiredServiceType">(optional) Actual registered or unwrapped service type to look for.</param>
            <param name="scope">(optional) Pre-request info: resolution scope.</param> // todo: v3: remove
            <param name="preResolveParent">(optional) Request info preceding Resolve call.</param>
            <returns>New request with provided info.</returns>
        </member>
        <member name="P:DryIoc.Request.IsEmpty">
            <summary>Indicates that request is empty initial request: there is no <see cref="P:DryIoc.Request.RequestInfo"/> in such a request.</summary>
        </member>
        <member name="F:DryIoc.Request.RawParent">
            <summary>Request parent with all runtime info available.</summary>
        </member>
        <member name="F:DryIoc.Request.Factory">
            <summary>Resolved factory, initially is null.</summary>
        </member>
        <member name="F:DryIoc.Request.FuncArgs">
            <summary>User provided arguments: key tracks what args are still unused.</summary>
            <remarks>Mutable: tracks used arguments</remarks>
        </member>
        <member name="P:DryIoc.Request.IsResolutionCall">
            <summary>Returns true if request is First in Resolve call.</summary>
        </member>
        <member name="P:DryIoc.Request.IsResolutionRoot">
            <summary>Returns true if request is First in First Resolve call.</summary>
        </member>
        <member name="P:DryIoc.Request.PreResolveParent">
            <summary>Request prior to Resolve call.</summary>
        </member>
        <member name="M:DryIoc.Request.IsWrappedInFunc">
            <summary>Checks if request is wrapped in Func,
             where Func is one of request immediate wrappers.</summary>
            <returns>True if has Func ancestor.</returns>
        </member>
        <member name="M:DryIoc.Request.IsWrappedInFuncWithArgs(System.Boolean)">
            <summary>Checks if request has parent with service type of Func with arguments.</summary>
            <param name="immediateParent">If set indicate to check for immediate parent only,
            otherwise will check whole parent chain.</param>
            <returns>True if has Func with arguments ancestor.</returns>
        </member>
        <member name="P:DryIoc.Request.TracksTransientDisposable">
            <summary>Indicates that requested service is transient disposable that should be tracked.</summary>
        </member>
        <member name="P:DryIoc.Request.IsSingletonOrDependencyOfSingleton">
            <summary>Indicates the request is singleton or has singleton upper in dependency chain.</summary>
        </member>
        <member name="P:DryIoc.Request.ContainsNestedResolutionCall">
            <summary>Gathers the info from resolved dependency graph.
            If dependency injected <c>asResolutionCall</c> the whole graph is not cacheable (issue #416).</summary>
            <returns>True if contains, false - otherwise or if not known.</returns>
        </member>
        <member name="P:DryIoc.Request.DependencyCount">
            <summary>Provides approximate number of dependencies in resolution graph (starting from Resolve method),
            excluding registered delegates, instances, and wrappers.</summary>
        </member>
        <member name="M:DryIoc.Request.ShouldSplitObjectGraph">
            <summary>Returns true if object graph should be split due <see cref="P:DryIoc.Rules.MaxObjectGraphSize"/> setting.</summary>
            <returns>True if should be split, and false otherwise.</returns>
        </member>
        <member name="P:DryIoc.Request.Parent">
            <summary>Returns service parent of request, skipping intermediate wrappers if any.</summary>
        </member>
        <member name="P:DryIoc.Request.ParentOrWrapper">
            <summary>Returns direct parent either it service or not (wrapper).
            In comparison with logical <see cref="P:DryIoc.Request.Parent"/> which returns first service parent skipping wrapper if any.</summary>
        </member>
        <member name="P:DryIoc.Request.Container">
            <summary>Provides access to container currently bound to request.
            By default it is container initiated request by calling resolve method,
            but could be changed along the way: for instance when resolving from parent container.</summary>
        </member>
        <member name="P:DryIoc.Request.Rules">
            <summary>Shortcut to issued container rules.</summary>
        </member>
        <member name="P:DryIoc.Request.Scopes">
            <summary>Separate from container because while container may be switched from parent to child, scopes should be from child/facade.</summary>
        </member>
        <member name="P:DryIoc.Request.SingletonScope">
            <summary>Singletons</summary>
        </member>
        <member name="P:DryIoc.Request.ContainerWeakRef">
            <summary>Weak reference to container. May be replaced in request flowed from parent to child container.</summary>
        </member>
        <member name="P:DryIoc.Request.Scope">
            <summary>Resolution scope.</summary>
        </member>
        <member name="P:DryIoc.Request.Made">
            <summary>(optional) Made spec used for resolving request.</summary>
        </member>
        <member name="P:DryIoc.Request.ServiceType">
            <summary>Requested service type.</summary>
        </member>
        <member name="P:DryIoc.Request.ServiceKey">
            <summary>Optional service key to identify service of the same type.</summary>
        </member>
        <member name="P:DryIoc.Request.MetadataKey">
            <summary>Metadata key to find in metadata dictionary in resolved service.</summary>
        </member>
        <member name="P:DryIoc.Request.Metadata">
            <summary>Metadata or the value (if key specified) to find in resolved service.</summary>
        </member>
        <member name="P:DryIoc.Request.IfUnresolved">
            <summary>Policy to deal with unresolved service.</summary>
        </member>
        <member name="P:DryIoc.Request.RequiredServiceType">
            <summary>Required service type if specified.</summary>
        </member>
        <member name="P:DryIoc.Request.FactoryID">
            <summary>Implementation FactoryID.</summary>
            <remarks>The default unassigned value of ID is 0.</remarks>
        </member>
        <member name="P:DryIoc.Request.FactoryType">
            <summary>Type of factory: Service, Wrapper, or Decorator.</summary>
        </member>
        <member name="P:DryIoc.Request.ImplementationType">
            <summary>Service implementation type if known.</summary>
        </member>
        <member name="P:DryIoc.Request.Reuse">
            <summary>Service reuse.</summary>
        </member>
        <member name="P:DryIoc.Request.ReuseLifespan">
            <summary>Relative number representing reuse lifespan.</summary>
        </member>
        <member name="P:DryIoc.Request.DecoratedFactoryID">
            <summary>Relative number representing reuse lifespan.</summary>
        </member>
        <member name="M:DryIoc.Request.GetActualServiceType">
            <summary>Returns result of <see cref="M:DryIoc.RequestInfo.GetActualServiceType"/>>.</summary>
            <returns>The type to be used for lookup in registry.</returns>
        </member>
        <member name="M:DryIoc.Request.GetKnownImplementationOrServiceType">
            <summary>Returns known implementation, or otherwise actual service type.</summary>
            <returns>The subject.</returns>
        </member>
        <member name="M:DryIoc.Request.Push(DryIoc.IServiceInfo,DryIoc.RequestFlags)">
            <summary>Creates new request with provided info, and attaches current request as new request parent.</summary>
            <param name="info">Info about service to resolve.</param>
            <param name="flags">(optional) Pushed flags.</param>
            <returns>New request for provided info.</returns>
            <remarks>Existing/parent request should be resolved to factory (<see cref="M:DryIoc.Request.WithResolvedFactory(DryIoc.Factory,System.Boolean,System.Boolean)"/>), before pushing info into it.</remarks>
        </member>
        <member name="M:DryIoc.Request.Push(System.Type,System.Object,DryIoc.IfUnresolved,System.Type,DryIoc.IScope,DryIoc.RequestInfo,DryIoc.RequestFlags)">
            <summary>Composes service description into <see cref="T:DryIoc.IServiceInfo"/> and calls Push.</summary>
            <param name="serviceType">Service type to resolve.</param>
            <param name="serviceKey">(optional) Service key to resolve.</param>
            <param name="ifUnresolved">(optional) Instructs how to handle unresolved service.</param>
            <param name="requiredServiceType">(optional) Registered/unwrapped service type to find.</param>
            <param name="scope">(optional) Resolution scope.</param>
            <param name="preResolveParent">(optional) Request info preceding Resolve call.</param>
            <param name="flags">(optional) Sets some flags.</param>
            <returns>New request with provided info.</returns>
        </member>
        <member name="M:DryIoc.Request.WithChangedServiceInfo(System.Func{DryIoc.IServiceInfo,DryIoc.IServiceInfo})">
            <summary>Allow to switch current service info to new one: for instance it is used be decorators.</summary>
            <param name="getInfo">Gets new info to switch to.</param>
            <returns>New request with new service info but the same implementation and context.</returns>
        </member>
        <member name="M:DryIoc.Request.ChangeServiceKey(System.Object)">
            <summary>Sets service key to passed value. Required for multiple default services to change null key to
            actual <see cref="T:DryIoc.DefaultKey"/></summary>
            <param name="serviceKey">Key to set.</param>
        </member>
        <member name="M:DryIoc.Request.WithArgs(System.Linq.Expressions.ParameterExpression[])">
            <summary>Adds input argument expression list to request.
            The arguments are provided by Func and Action wrappers.</summary>
            <param name="argExpressions">Argument parameter expressions.</param> <returns>New request.</returns>
        </member>
        <member name="M:DryIoc.Request.WithFuncArgs(System.Type)">
            <summary>Obsolete: replaced with <see cref="M:DryIoc.Request.WithArgs(System.Linq.Expressions.ParameterExpression[])"/>.</summary>
        </member>
        <member name="M:DryIoc.Request.WithNewContainer(DryIoc.ContainerWeakRef)">
            <summary>Changes container to passed one. Could be used by child container,
            to switch child container to parent preserving the rest of request state.</summary>
            <param name="newContainer">Reference to container to switch to.</param>
            <returns>Request with replaced container.</returns>
        </member>
        <member name="M:DryIoc.Request.WithResolvedFactory(DryIoc.Factory,System.Boolean,System.Boolean)">
            <summary>Returns new request with set implementation details.</summary>
            <param name="factory">Factory to which request is resolved.</param>
            <param name="skipRecursiveDependencyCheck">(optional) does not check for recursive dependency.
            Use with caution. Make sense for Resolution expression.</param>
            <param name="skipCaptiveDependencyCheck">(optional) allows to skip captive dependency check.</param>
            <returns>New request with set factory.</returns>
        </member>
        <member name="P:DryIoc.Request.RequestInfo">
            <summary>Serializable request info stripped off run-time info.</summary>
        </member>
        <member name="M:DryIoc.Request.ToRequestInfo">
            <summary>Obsolete: use <see cref="P:DryIoc.Request.RequestInfo"/> instead.</summary>
        </member>
        <member name="M:DryIoc.Request.Is``1(System.Func{``0},System.Func{System.Reflection.ParameterInfo,``0},System.Func{System.Reflection.PropertyInfo,``0},System.Func{System.Reflection.FieldInfo,``0})">
            <summary>If request corresponds to dependency injected into parameter,
            then method calls <paramref name="parameter"/> handling and returns its result.
            If request corresponds to property or field, then method calls respective handler.
            If request does not correspond to dependency, then calls <paramref name="root"/> handler.</summary>
            <typeparam name="TResult"></typeparam>
            <param name="root">(optional) handler for resolution call or root.</param>
            <param name="parameter">(optional) handler for parameter dependency</param>
            <param name="property">(optional) handler for property dependency</param>
            <param name="field">(optional) handler for field dependency</param>
            <returns>Result of applied handler or default <typeparamref name="TResult"/>.</returns>
        </member>
        <member name="M:DryIoc.Request.Enumerate">
            <summary>Enumerates all request stack parents.
            Last returned will <see cref="P:DryIoc.Request.IsEmpty"/> empty parent.</summary>
            <returns>Unfolding parents.</returns>
        </member>
        <member name="M:DryIoc.Request.PrintCurrent(System.Text.StringBuilder)">
            <summary>Prints current request info only (no parents printed) to provided builder.</summary>
            <param name="s">Builder to print too.</param>
            <returns>(optional) Builder to appended info to, or new builder if not specified.</returns>
        </member>
        <member name="M:DryIoc.Request.Print(System.Int32)">
            <summary>Prints full stack of requests starting from current one using <see cref="M:DryIoc.Request.PrintCurrent(System.Text.StringBuilder)"/>.</summary>
            <param name="recursiveFactoryID">Flag specifying that in case of found recursion/repetition of requests,
            mark repeated requests.</param>
            <returns>Builder with appended request stack info.</returns>
        </member>
        <member name="M:DryIoc.Request.ToString">
            <summary>Print while request stack info to string using <seealso cref="M:DryIoc.Request.Print(System.Int32)"/>.</summary>
            <returns>String with info.</returns>
        </member>
        <member name="T:DryIoc.FactoryType">
            <summary>Type of services supported by Container.</summary>
        </member>
        <member name="F:DryIoc.FactoryType.Service">
            <summary>(default) Defines normal service factory</summary>
        </member>
        <member name="F:DryIoc.FactoryType.Decorator">
            <summary>Defines decorator factory</summary>
        </member>
        <member name="F:DryIoc.FactoryType.Wrapper">
            <summary>Defines wrapper factory.</summary>
        </member>
        <member name="T:DryIoc.Setup">
            <summary>Base class to store optional <see cref="T:DryIoc.Factory"/> settings.</summary>
        </member>
        <member name="P:DryIoc.Setup.FactoryType">
            <summary>Factory type is required to be specified by concrete setups as in
            <see cref="T:DryIoc.Setup.ServiceSetup"/>, <see cref="T:DryIoc.Setup.DecoratorSetup"/>, <see cref="T:DryIoc.Setup.WrapperSetup"/>.</summary>
        </member>
        <member name="P:DryIoc.Setup.Condition">
            <summary>Predicate to check if factory could be used for resolved request.</summary>
        </member>
        <member name="P:DryIoc.Setup.Metadata">
            <summary>Arbitrary metadata object associated with Factory/Implementation.</summary>
        </member>
        <member name="P:DryIoc.Setup.AsResolutionCall">
            <summary>Indicates that injected expression should be:
            <c><![CDATA[r.Resolver.Resolve<IDependency>(...)]]></c>
            instead of: <c><![CDATA[new Dependency(...)]]></c></summary>
        </member>
        <member name="P:DryIoc.Setup.AsResolutionRoot">
            <summary>Marks service (not a wrapper or decorator) registration that is expected to be resolved via Resolve call.</summary>
        </member>
        <member name="P:DryIoc.Setup.OpenResolutionScope">
            <summary>In addition to <see cref="P:DryIoc.Setup.AsResolutionCall"/> opens scope.</summary>
        </member>
        <member name="P:DryIoc.Setup.PreventDisposal">
            <summary>Prevents disposal of reused instance if it is disposable.</summary>
        </member>
        <member name="P:DryIoc.Setup.WeaklyReferenced">
            <summary>Stores reused instance as WeakReference.</summary>
        </member>
        <member name="P:DryIoc.Setup.AllowDisposableTransient">
            <summary>Allows registering transient disposable.</summary>
        </member>
        <member name="P:DryIoc.Setup.TrackDisposableTransient">
            <summary>Turns On tracking of disposable transient dependency in parent scope or in open scope if resolved directly.</summary>
        </member>
        <member name="P:DryIoc.Setup.UseParentReuse">
            <summary>Instructs to use parent reuse. Applied only if <see cref="P:DryIoc.Factory.Reuse"/> is not specified.</summary>
        </member>
        <member name="M:DryIoc.Setup.MatchesMetadata(System.String,System.Object)">
            <summary>Returns true if passed meta key and value match the setup metadata.</summary>
            <param name="metadataKey">Required metadata key</param> <param name="metadata">Required metadata or the value if key passed.</param>
            <returns>Check result.</returns>
        </member>
        <member name="F:DryIoc.Setup.Default">
            <summary>Default setup for service factories.</summary>
        </member>
        <member name="M:DryIoc.Setup.#ctor(System.Func{DryIoc.Request,System.Boolean},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Sets the base settings.</summary>
            <param name="condition"></param>
            <param name="openResolutionScope"></param> <param name="asResolutionCall"></param>
            <param name="asResolutionRoot"></param> <param name="preventDisposal"></param>
            <param name="weaklyReferenced"></param> <param name="allowDisposableTransient"></param>
            <param name="trackDisposableTransient"></param> <param name="useParentReuse"></param>
        </member>
        <member name="M:DryIoc.Setup.With(System.Object,System.Func{DryIoc.RequestInfo,System.Boolean},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Constructs setup object out of specified settings. If all settings are default then <see cref="F:DryIoc.Setup.Default"/> setup will be returned.</summary>
            <param name="metadataOrFuncOfMetadata">(optional) Metadata object or Func returning metadata object.</param>
            <param name="condition">(optional)</param>
            <param name="openResolutionScope">(optional) Same as <paramref name="asResolutionCall"/> but in addition opens new scope.</param>
            <param name="asResolutionCall">(optional) If true dependency expression will be "r.Resolve(...)" instead of inline expression.</param>
            <param name="asResolutionRoot">(optional) Marks service (not a wrapper or decorator) registration that is expected to be resolved via Resolve call.</param>
            <param name="preventDisposal">(optional) Prevents disposal of reused instance if it is disposable.</param>
            <param name="weaklyReferenced">(optional) Stores reused instance as WeakReference.</param>
            <param name="allowDisposableTransient">(optional) Allows registering transient disposable.</param>
            <param name="trackDisposableTransient">(optional) Turns On tracking of disposable transient dependency in parent scope or in open scope if resolved directly.</param>
            <param name="useParentReuse">(optional) Instructs to use parent reuse. Applied only if <see cref="P:DryIoc.Factory.Reuse"/> is not specified.</param>
            <returns>New setup object or <see cref="F:DryIoc.Setup.Default"/>.</returns>
        </member>
        <member name="M:DryIoc.Setup.With(System.Object,System.Func{DryIoc.Request,System.Boolean},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Constructs setup object out of specified settings. If all settings are default then <see cref="F:DryIoc.Setup.Default"/> setup will be returned.</summary>
            <param name="metadataOrFuncOfMetadata">Metadata object or Func returning metadata object.</param>
            <param name="condition"></param>
            <param name="openResolutionScope">(optional) Same as <paramref name="asResolutionCall"/> but in addition opens new scope.</param>
            <param name="asResolutionCall">(optional) If true dependency expression will be "r.Resolve(...)" instead of inline expression.</param>
            <param name="asResolutionRoot">(optional) Marks service (not a wrapper or decorator) registration that is expected to be resolved via Resolve call.</param>
            <param name="preventDisposal">(optional) Prevents disposal of reused instance if it is disposable.</param>
            <param name="weaklyReferenced">(optional) Stores reused instance as WeakReference.</param>
            <param name="allowDisposableTransient">(optional) Allows registering transient disposable.</param>
            <param name="trackDisposableTransient">(optional) Turns On tracking of disposable transient dependency in parent scope or in open scope if resolved directly.</param>
            <param name="useParentReuse">(optional) Instructs to use parent reuse. Applied only if <see cref="P:DryIoc.Factory.Reuse"/> is not specified.</param>
            <returns>New setup object or <see cref="F:DryIoc.Setup.Default"/>.</returns>
        </member>
        <member name="F:DryIoc.Setup.Wrapper">
            <summary>Default setup which will look for wrapped service type as single generic parameter.</summary>
        </member>
        <member name="M:DryIoc.Setup.WrapperWith(System.Func{DryIoc.Request,System.Boolean},System.Int32,System.Boolean,System.Func{System.Type,System.Type},System.Boolean,System.Boolean,System.Boolean)">
            <summary>Returns generic wrapper setup.</summary>
            <param name="condition">(optional)</param>
            <param name="wrappedServiceTypeArgIndex">Default is -1 for generic wrapper with single type argument. Need to be set for multiple type arguments.</param>
            <param name="alwaysWrapsRequiredServiceType">Need to be set when generic wrapper type arguments should be ignored.</param>
            <param name="unwrap">(optional) Delegate returning wrapped type from wrapper type. <b>Overwrites other options.</b></param>
            <param name="openResolutionScope">(optional) Opens the new scope.</param>
            <param name="asResolutionCall">(optional) Injects decorator as resolution call.</param>
            <param name="preventDisposal">(optional) Prevents disposal of reused instance if it is disposable.</param>
            <returns>New setup or default <see cref="F:DryIoc.Setup.Wrapper"/>.</returns>
        </member>
        <member name="M:DryIoc.Setup.WrapperWith(System.Int32,System.Boolean,System.Func{System.Type,System.Type},System.Boolean,System.Boolean,System.Boolean,System.Func{DryIoc.RequestInfo,System.Boolean})">
            <summary>Returns generic wrapper setup.</summary>
            <param name="wrappedServiceTypeArgIndex">Default is -1 for generic wrapper with single type argument. Need to be set for multiple type arguments.</param>
            <param name="alwaysWrapsRequiredServiceType">Need to be set when generic wrapper type arguments should be ignored.</param>
            <param name="unwrap">(optional) Delegate returning wrapped type from wrapper type. <b>Overwrites other options.</b></param>
            <param name="openResolutionScope">(optional) Opens the new scope.</param>
            <param name="asResolutionCall">(optional) Injects decorator as resolution call.</param>
            <param name="preventDisposal">(optional) Prevents disposal of reused instance if it is disposable.</param>
            <param name="condition">(optional)</param>
            <returns>New setup or default <see cref="F:DryIoc.Setup.Wrapper"/>.</returns>
        </member>
        <member name="F:DryIoc.Setup.Decorator">
            <summary>Default decorator setup: decorator is applied to service type it registered with.</summary>
        </member>
        <member name="M:DryIoc.Setup.DecoratorWith(System.Func{DryIoc.RequestInfo,System.Boolean},System.Int32,System.Boolean)">
            <summary>Creates setup with optional condition.</summary>
            <param name="condition">Applied to decorated service, if true then decorator is applied.</param>
            <param name="order">(optional) If provided specifies relative decorator position in decorators chain.</param>
            <param name="useDecorateeReuse">If provided specifies relative decorator position in decorators chain.
            Greater number means further from decoratee - specify negative number to stay closer.
            Decorators without order (Order is 0) or with equal order are applied in registration order
            - first registered are closer decoratee.</param>
            <returns>New setup with condition or <see cref="F:DryIoc.Setup.Decorator"/>.</returns>
        </member>
        <member name="M:DryIoc.Setup.DecoratorWith(System.Func{DryIoc.Request,System.Boolean},System.Int32,System.Boolean)">
            <summary>Creates setup with condition.</summary>
            <param name="condition">Applied to decorated service, if true then decorator is applied.</param>
            <param name="order">(optional) If provided specifies relative decorator position in decorators chain.</param>
            <param name="useDecorateeReuse">If provided specifies relative decorator position in decorators chain.
            Greater number means further from decoratee - specify negative number to stay closer.
            Decorators without order (Order is 0) or with equal order are applied in registration order
            - first registered are closer decoratee.</param>
            <returns>New setup with condition or <see cref="F:DryIoc.Setup.Decorator"/>.</returns>
        </member>
        <member name="M:DryIoc.Setup.DecoratorOf(System.Type,System.Int32,System.Boolean,System.Object)">
            <summary>Creates setup with optional condition.</summary>
            <param name="decorateeType">(optional) Type that should be implemented by decorated service.</param>
            <param name="decorateeServiceKey">(optional) Identifies keyed decorated service.</param>
            <param name="order">(optional) If provided specifies relative decorator position in decorators chain.</param>
            <param name="useDecorateeReuse">If provided specifies relative decorator position in decorators chain.
            Greater number means further from decoratee - specify negative number to stay closer.
            Decorators without order (Order is 0) or with equal order are applied in registration order
            - first registered are closer decoratee.</param>
            <returns>New setup with condition or <see cref="F:DryIoc.Setup.Decorator"/>.</returns>
        </member>
        <member name="M:DryIoc.Setup.DecoratorOf``1(System.Int32,System.Boolean,System.Object)">
            <summary>Creates setup with optional condition.</summary>
            <typeparam name="TDecoratee">Type that should be implemented by decorated service.</typeparam>
            <param name="decorateeServiceKey">(optional) Identifies keyed decorated service.</param>
            <param name="order">(optional) If provided specifies relative decorator position in decorators chain.</param>
            <param name="useDecorateeReuse">If provided specifies relative decorator position in decorators chain.
            Greater number means further from decoratee - specify negative number to stay closer.
            Decorators without order (Order is 0) or with equal order are applied in registration order
            - first registered are closer decoratee.</param>
            <returns>New setup with condition or <see cref="F:DryIoc.Setup.Decorator"/>.</returns>
        </member>
        <member name="T:DryIoc.Setup.ServiceSetup">
            <summary>Service setup.</summary>
        </member>
        <member name="P:DryIoc.Setup.ServiceSetup.FactoryType">
            <inheritdoc />
        </member>
        <member name="P:DryIoc.Setup.ServiceSetup.Metadata">
            <summary>Evaluates metadata if it specified as Func of object, and replaces Func with its result!.
            Otherwise just returns metadata object.</summary>
            <remarks>Invocation of Func metadata is Not thread-safe. Please take care of that inside the Func.</remarks>
        </member>
        <member name="M:DryIoc.Setup.ServiceSetup.#ctor">
            <summary>All settings are set to defaults.</summary>
        </member>
        <member name="M:DryIoc.Setup.ServiceSetup.#ctor(System.Func{DryIoc.Request,System.Boolean},System.Object,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Specify an individual settings</summary>
        </member>
        <member name="T:DryIoc.Setup.WrapperSetup">
            <summary>Setup applied for wrappers.</summary>
        </member>
        <member name="P:DryIoc.Setup.WrapperSetup.FactoryType">
            <summary>Returns <see cref="F:DryIoc.FactoryType.Wrapper"/> type.</summary>
        </member>
        <member name="F:DryIoc.Setup.WrapperSetup.WrappedServiceTypeArgIndex">
            <summary>Delegate to get wrapped type from provided wrapper type.
            If wrapper is generic, then wrapped type is usually a generic parameter.</summary>
        </member>
        <member name="F:DryIoc.Setup.WrapperSetup.AlwaysWrapsRequiredServiceType">
            <summary>Per name.</summary>
        </member>
        <member name="F:DryIoc.Setup.WrapperSetup.Unwrap">
            <summary>Delegate returning wrapped type from wrapper type. Overwrites other options.</summary>
        </member>
        <member name="M:DryIoc.Setup.WrapperSetup.#ctor(System.Int32)">
            <summary>Default setup</summary>
            <param name="wrappedServiceTypeArgIndex">Default is -1 for generic wrapper with single type argument.
            Need to be set for multiple type arguments.</param>
        </member>
        <member name="M:DryIoc.Setup.WrapperSetup.#ctor(System.Int32,System.Boolean,System.Func{System.Type,System.Type},System.Func{DryIoc.Request,System.Boolean},System.Boolean,System.Boolean,System.Boolean)">
            <summary>Constructs wrapper setup from optional wrapped type selector and reuse wrapper factory.</summary>
            <param name="wrappedServiceTypeArgIndex">Default is -1 for generic wrapper with single type argument. Need to be set for multiple type arguments.</param>
            <param name="alwaysWrapsRequiredServiceType">Need to be set when generic wrapper type arguments should be ignored.</param>
            <param name="unwrap">Delegate returning wrapped type from wrapper type.  Overwrites other options.</param>
            <param name="openResolutionScope">Opens the new scope.</param><param name="asResolutionCall"></param>
            <param name="preventDisposal">Prevents disposal of reused instance if it is disposable.</param>
            <param name="condition">Predicate to check if factory could be used for resolved request.</param>
        </member>
        <member name="M:DryIoc.Setup.WrapperSetup.GetWrappedTypeOrNullIfWrapsRequired(System.Type)">
            <summary>Unwraps service type or returns its.</summary>
            <param name="serviceType"></param> <returns>Wrapped type or self.</returns>
        </member>
        <member name="T:DryIoc.Setup.DecoratorSetup">
            <summary>Setup applied to decorators.</summary>
        </member>
        <member name="P:DryIoc.Setup.DecoratorSetup.FactoryType">
            <summary>Returns Decorator factory type.</summary>
        </member>
        <member name="F:DryIoc.Setup.DecoratorSetup.Order">
            <summary>If provided specifies relative decorator position in decorators chain.
            Greater number means further from decoratee - specify negative number to stay closer.
            Decorators without order (Order is 0) or with equal order are applied in registration order
            - first registered are closer decoratee.</summary>
        </member>
        <member name="F:DryIoc.Setup.DecoratorSetup.UseDecorateeReuse">
            <summary>Instructs to use decorated service reuse. Decorated service may be decorator itself.</summary>
        </member>
        <member name="M:DryIoc.Setup.DecoratorSetup.#ctor">
            <summary>Default setup.</summary>
        </member>
        <member name="M:DryIoc.Setup.DecoratorSetup.#ctor(System.Func{DryIoc.Request,System.Boolean},System.Int32,System.Boolean)">
            <summary>Creates decorator setup with optional condition.</summary>
            <param name="condition">(optional) Applied to decorated service to find that service is the decorator target.</param>
            <param name="order">(optional) If provided specifies relative decorator position in decorators chain.
            Greater number means further from decoratee - specify negative number to stay closer.
            Decorators without order (Order is 0) or with equal order are applied in registration order
            - first registered are closer decoratee.</param>
            <param name="useDecorateeReuse">(optional) Instructs to use decorated service reuse.
            Decorated service may be decorator itself.</param>
        </member>
        <member name="T:DryIoc.IConcreteFactoryGenerator">
            <summary>Facility for creating concrete factories from some template/prototype. Example:
            creating closed-generic type reflection factory from registered open-generic prototype factory.</summary>
        </member>
        <member name="P:DryIoc.IConcreteFactoryGenerator.GeneratedFactories">
            <summary>Generated factories so far, identified by the service type and key pair.</summary>
        </member>
        <member name="M:DryIoc.IConcreteFactoryGenerator.GetGeneratedFactory(DryIoc.Request,System.Boolean)">
            <summary>Returns factory per request. May track already generated factories and return one without regenerating.</summary>
            <param name="request">Request to resolve.</param>
            <param name="ifErrorReturnDefault">If set to true - returns null if unable to generate,
            otherwise error result depends on <see cref="P:DryIoc.Request.IfUnresolved"/>.</param>
            <returns>Returns new factory per request.</returns>
        </member>
        <member name="T:DryIoc.Factory">
            <summary>Base class for different ways to instantiate service:
            <list type="bullet">
            <item>Through reflection - <see cref="T:DryIoc.ReflectionFactory"/></item>
            <item>Using custom delegate - <see cref="T:DryIoc.DelegateFactory"/></item>
            <item>Using custom expression - <see cref="T:DryIoc.ExpressionFactory"/></item>
            </list>
            For all of the types Factory should provide result as <see cref="T:System.Linq.Expressions.Expression"/> and <see cref="T:DryIoc.FactoryDelegate"/>.
            Factories are supposed to be immutable and stateless.
            Each created factory has an unique ID set in <see cref="P:DryIoc.Factory.FactoryID"/>.</summary>
        </member>
        <member name="M:DryIoc.Factory.GetNextID">
            <summary>Get next factory ID in a atomic way.</summary><returns>The ID.</returns>
        </member>
        <member name="P:DryIoc.Factory.FactoryID">
            <summary>Unique factory id generated from static seed.</summary>
        </member>
        <member name="P:DryIoc.Factory.Reuse">
            <summary>Reuse policy for created services.</summary>
        </member>
        <member name="P:DryIoc.Factory.Setup">
            <summary>Setup may contain different/non-default factory settings.</summary>
        </member>
        <member name="M:DryIoc.Factory.CheckCondition(DryIoc.Request)">
            <summary>Checks that condition is met for request or there is no condition setup.
            Additionally check for reuse scope availability.</summary>
            <param name="request">Request to check against.</param>
            <returns>True if condition met or no condition setup.</returns>
        </member>
        <member name="P:DryIoc.Factory.FactoryType">
            <summary>Shortcut for <see cref="P:DryIoc.Setup.FactoryType"/>.</summary>
        </member>
        <member name="P:DryIoc.Factory.ImplementationType">
            <summary>Non-abstract closed implementation type. May be null if not known beforehand, e.g. in <see cref="T:DryIoc.DelegateFactory"/>.</summary>
        </member>
        <member name="P:DryIoc.Factory.CanAccessImplementationType">
            <summary>Allow inheritors to define lazy implementation type</summary>
        </member>
        <member name="P:DryIoc.Factory.FactoryGenerator">
            <summary>Indicates that Factory is factory provider and
            consumer should call <see cref="M:DryIoc.IConcreteFactoryGenerator.GetGeneratedFactory(DryIoc.Request,System.Boolean)"/>  to get concrete factory.</summary>
        </member>
        <member name="P:DryIoc.Factory.Made">
            <summary>Settings <b>(if any)</b> to select Constructor/FactoryMethod, Parameters, Properties and Fields.</summary>
        </member>
        <member name="M:DryIoc.Factory.#ctor(DryIoc.IReuse,DryIoc.Setup)">
            <summary>Initializes reuse and setup. Sets the <see cref="P:DryIoc.Factory.FactoryID"/></summary>
            <param name="reuse">(optional)</param> <param name="setup">(optional)</param>
        </member>
        <member name="M:DryIoc.Factory.HasMatchingReuseScope(DryIoc.Request)">
            <summary>Returns true if for factory Reuse exists matching resolution or current Scope.</summary>
            <param name="request"></param> <returns>True if matching Scope exists.</returns>
        </member>
        <member name="M:DryIoc.Factory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>The main factory method to create service expression, e.g. "new Client(new Service())".
            If <paramref name="request"/> has <see cref="F:DryIoc.Request.FuncArgs"/> specified, they could be used in expression.</summary>
            <param name="request">Service request.</param>
            <returns>Created expression.</returns>
        </member>
        <member name="M:DryIoc.Factory.IsFactoryExpressionCacheable(DryIoc.Request)">
            <summary>Allows derived factories to override or reuse caching policy used by
            GetExpressionOrDefault. By default only service setup and no  user passed arguments may be cached.</summary>
            <param name="request">Context.</param> <returns>True if factory expression could be cached.</returns>
        </member>
        <member name="M:DryIoc.Factory.GetExpressionOrDefault(DryIoc.Request)">
            <summary>Returns service expression: either by creating it with <see cref="M:DryIoc.Factory.CreateExpressionOrDefault(DryIoc.Request)"/> or taking expression from cache.
            Before returning method may transform the expression  by applying <see cref="P:DryIoc.Factory.Reuse"/>, or/and decorators if found any.</summary>
            <param name="request">Request for service.</param> <returns>Service expression.</returns>
        </member>
        <member name="M:DryIoc.Factory.ApplyReuse(System.Linq.Expressions.Expression,DryIoc.IReuse,System.Boolean,DryIoc.Request)">
            <summary>Applies reuse to created expression.  Actually wraps passed expression in scoped access
            and produces another expression.</summary>
            <param name="serviceExpr">Raw service creation (or receiving) expression.</param>
            <param name="reuse">Reuse - may be different from <see cref="P:DryIoc.Factory.Reuse"/> if set <see cref="P:DryIoc.Rules.DefaultReuseInsteadOfTransient"/>.</param>
            <param name="tracksTransientDisposable">Specifies that reuse is to track transient disposable.</param>
            <param name="request">Context.</param>
            <returns>Scoped expression or originally passed expression.</returns>
        </member>
        <member name="M:DryIoc.Factory.GetDelegateOrDefault(DryIoc.Request)">
            <summary>Creates factory delegate from service expression and returns it.
            to compile delegate from expression but could be overridden by concrete factory type: e.g. <see cref="T:DryIoc.DelegateFactory"/></summary>
            <param name="request">Service request.</param>
            <returns>Factory delegate created from service expression.</returns>
        </member>
        <member name="M:DryIoc.Factory.ToString">
            <summary>Returns nice string representation of factory.</summary>
            <returns>String representation.</returns>
        </member>
        <member name="T:DryIoc.FactoryMethodSelector">
            <summary>Declares delegate to get single factory method or constructor for resolved request.</summary>
            <param name="request">Request to resolve.</param>
            <returns>Factory method wrapper over constructor or method.</returns>
        </member>
        <member name="T:DryIoc.ParameterSelector">
            <summary>Specifies how to get parameter info for injected parameter and resolved request</summary>
            <remarks>Request is for parameter method owner not for parameter itself.</remarks>
            <param name="request">Request for parameter method/constructor owner.</param>
            <returns>Service info describing how to inject parameter.</returns>
        </member>
        <member name="T:DryIoc.PropertiesAndFieldsSelector">
            <summary>Specifies what properties or fields to inject and how.</summary>
            <param name="request">Request for property/field owner.</param>
            <returns>Corresponding service info for each property/field to be injected.</returns>
        </member>
        <member name="T:DryIoc.Parameters">
            <summary>DSL for specifying <see cref="T:DryIoc.ParameterSelector"/> injection rules.</summary>
        </member>
        <member name="F:DryIoc.Parameters.Of">
            <summary>Returns default service info wrapper for each parameter info.</summary>
        </member>
        <member name="F:DryIoc.Parameters.IfUnresolvedReturnDefault">
            <summary>Returns service info which considers each parameter as optional.</summary>
        </member>
        <member name="M:DryIoc.Parameters.OverrideWith(DryIoc.ParameterSelector,DryIoc.ParameterSelector)">
            <summary>Combines source selector with other. Other is used as fallback when source returns null.</summary>
            <param name="source">Source selector.</param> <param name="other">Specific other selector to add.</param>
            <returns>Combined result selector.</returns>
        </member>
        <member name="M:DryIoc.Parameters.And(DryIoc.ParameterSelector,DryIoc.ParameterSelector)">
            <summary>Obsolete: use <see cref="M:DryIoc.Parameters.OverrideWith(DryIoc.ParameterSelector,DryIoc.ParameterSelector)"/>.</summary>
        </member>
        <member name="M:DryIoc.Parameters.Details(DryIoc.ParameterSelector,System.Func{DryIoc.Request,System.Reflection.ParameterInfo,DryIoc.ServiceDetails})">
            <summary>Overrides source parameter rules with specific parameter details. If it is not your parameter just return null.</summary>
            <param name="source">Original parameters rules</param>
            <param name="getDetailsOrNull">Should return specific details or null.</param>
            <returns>New parameters rules.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Name(DryIoc.ParameterSelector,System.String,System.Type,System.Object,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Adds to <paramref name="source"/> selector service info for parameter identified by <paramref name="name"/>.</summary>
            <param name="source">Original parameters rules.</param> <param name="name">Name to identify parameter.</param>
            <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="ifUnresolved">(optional) By default throws exception if unresolved.</param>
            <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
            <param name="metadataKey">(optional) Required metadata key</param> <param name="metadata">Required metadata or value.</param>
            <returns>New parameters rules.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Name(DryIoc.ParameterSelector,System.String,System.Func{DryIoc.Request,System.Object})">
            <summary>Specify parameter by name and set custom value to it.</summary>
            <param name="source">Original parameters rules.</param> <param name="name">Parameter name.</param>
            <param name="getCustomValue">Custom value provider.</param>
            <returns>New parameters rules.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Type``1(DryIoc.ParameterSelector,System.Type,System.Object,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Adds to <paramref name="source"/> selector service info for parameter identified by type <typeparamref name="T"/>.</summary>
            <typeparam name="T">Type of parameter.</typeparam> <param name="source">Source selector.</param>
            <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="ifUnresolved">(optional) By default throws exception if unresolved.</param>
            <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
            <param name="metadataKey">(optional) Required metadata key</param> <param name="metadata">Required metadata or value.</param>
            <returns>Combined selector.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Type``1(DryIoc.ParameterSelector,System.Func{DryIoc.Request,``0})">
            <summary>Specify parameter by type and set custom value to it.</summary>
            <typeparam name="T">Parameter type.</typeparam>
            <param name="source">Original parameters rules.</param>
            <param name="getCustomValue">Custom value provider.</param>
            <returns>New parameters rules.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Type(DryIoc.ParameterSelector,System.Type,System.Type,System.Object,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Adds to <paramref name="source"/> selector service info for parameter identified by type <paramref name="parameterType"/>.</summary>
            <param name="source">Source selector.</param> <param name="parameterType">The type of the parameter.</param>
            <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="ifUnresolved">(optional) By default throws exception if unresolved.</param>
            <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
            <param name="metadataKey">(optional) Required metadata key</param> <param name="metadata">Required metadata or value.</param>
            <returns>Combined selector.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Type(DryIoc.ParameterSelector,System.Type,System.Func{DryIoc.Request,System.Object})">
            <summary>Specify parameter by type and set custom value to it.</summary>
            <param name="source">Original parameters rules.</param>
            <param name="parameterType">The type of the parameter.</param>
            <param name="getCustomValue">Custom value provider.</param>
            <returns>New parameters rules.</returns>
        </member>
        <member name="T:DryIoc.PropertiesAndFields">
            <summary>DSL for specifying <see cref="T:DryIoc.PropertiesAndFieldsSelector"/> injection rules.</summary>
        </member>
        <member name="F:DryIoc.PropertiesAndFields.Of">
            <summary>Say to not resolve any properties or fields.</summary>
        </member>
        <member name="F:DryIoc.PropertiesAndFields.Auto">
            <summary>Public assignable instance members of any type except object, string, primitives types, and arrays of those.</summary>
        </member>
        <member name="T:DryIoc.PropertiesAndFields.GetInfo">
            <summary>Should return service info for input member (property or field).</summary>
            <param name="member">Input member.</param> <param name="request">Request to provide context.</param> <returns>Service info.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.All(System.Boolean,System.Boolean,System.Boolean,DryIoc.IfUnresolved,DryIoc.PropertiesAndFields.GetInfo)">
            <summary>Generates selector property and field selector with settings specified by parameters.
            If all parameters are omitted the return all public not primitive members.</summary>
            <param name="withNonPublic">(optional) Specifies to include non public members. Will include by default.</param>
            <param name="withPrimitive">(optional) Specifies to include members of primitive types. Will include by default.</param>
            <param name="withFields">(optional) Specifies to include fields as well as properties. Will include by default.</param>
            <param name="ifUnresolved">(optional) Defines ifUnresolved behavior for resolved members.</param>
            <param name="withInfo">(optional) Return service info for a member or null to skip member resolution.</param>
            <returns>Result selector composed using provided settings.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.OverrideWith(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Combines source properties and fields with other. Other will override the source condition.</summary>
            <param name="source">Source selector.</param> <param name="other">Specific other selector to add.</param>
            <returns>Combined result selector.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.And(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Obsolete: renamed to <see cref="M:DryIoc.PropertiesAndFields.OverrideWith(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)"/>.</summary>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Details(DryIoc.PropertiesAndFieldsSelector,System.String,System.Func{DryIoc.Request,DryIoc.ServiceDetails})">
            <summary>Specifies service details (key, if-unresolved policy, required type) for property/field with the name.</summary>
            <param name="source">Original member selector.</param> <param name="name">Member name.</param> <param name="getDetails">Details.</param>
            <returns>New selector.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Name(DryIoc.PropertiesAndFieldsSelector,System.String,System.Type,System.Object,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Adds to <paramref name="source"/> selector service info for property/field identified by <paramref name="name"/>.</summary>
            <param name="source">Source selector.</param> <param name="name">Name to identify member.</param>
            <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="ifUnresolved">(optional) By default returns default value if unresolved.</param>
            <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
            <param name="metadataKey">(optional) Required metadata key</param> <param name="metadata">Required metadata or value.</param>
            <returns>Combined selector.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Name(DryIoc.PropertiesAndFieldsSelector,System.String,System.Func{DryIoc.Request,System.Object})">
            <summary>Specifies custom value for property/field with specific name.</summary>
            <param name="source">Original property/field list.</param>
            <param name="name">Target member name.</param> <param name="getCustomValue">Custom value provider.</param>
            <returns>Return new combined selector.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.IsInjectable(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <summary>Returns true if property matches flags provided.</summary>
            <param name="property">Property to match</param>
            <param name="withNonPublic">Says to include non public properties.</param>
            <param name="withPrimitive">Says to include properties of primitive type.</param>
            <returns>True if property is matched and false otherwise.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.IsInjectable(System.Reflection.FieldInfo,System.Boolean,System.Boolean)">
            <summary>Returns true if field matches flags provided.</summary>
            <param name="field">Field to match.</param>
            <param name="withNonPublic">Says to include non public fields.</param>
            <param name="withPrimitive">Says to include fields of primitive type.</param>
            <returns>True if property is matched and false otherwise.</returns>
        </member>
        <member name="T:DryIoc.ReflectionFactory">
            <summary>Reflects on <see cref="P:DryIoc.ReflectionFactory.ImplementationType"/> constructor parameters and members,
            creates expression for each reflected dependency, and composes result service expression.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.ImplementationType">
            <summary>Non-abstract service implementation type. May be open generic.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.CanAccessImplementationType">
            <summary>False for lazy implementation type, to prevent its early materialization.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.FactoryGenerator">
            <summary>Provides closed-generic factory for registered open-generic variant.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.Made">
            <summary>Injection rules set for Constructor/FactoryMethod, Parameters, Properties and Fields.</summary>
        </member>
        <member name="M:DryIoc.ReflectionFactory.#ctor(System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup)">
            <summary>Creates factory providing implementation type, optional reuse and setup.</summary>
            <param name="implementationType">(optional) Optional if Made.FactoryMethod is present Non-abstract close or open generic type.</param>
            <param name="reuse">(optional)</param> <param name="made">(optional)</param> <param name="setup">(optional)</param>
        </member>
        <member name="M:DryIoc.ReflectionFactory.#ctor(System.Func{System.Type},DryIoc.IReuse,DryIoc.Made,DryIoc.Setup)">
            <summary>Creates factory providing implementation type, optional reuse and setup.</summary>
            <param name="implementationTypeProvider">Provider of non-abstract close or open generic type.</param>
            <param name="reuse">(optional)</param> <param name="made">(optional)</param> <param name="setup">(optional)</param>
        </member>
        <member name="M:DryIoc.ReflectionFactory.IsFactoryExpressionCacheable(DryIoc.Request)">
            <summary>Add to base rules: do not cache if Made is context based.</summary>
            <param name="request">Context.</param> <returns>True if factory expression could be cached.</returns>
        </member>
        <member name="M:DryIoc.ReflectionFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>Creates service expression, so for registered implementation type "Service",
            you will get "new Service()". If there is <see cref="T:DryIoc.Reuse"/> specified, then expression will
            contain call to <see cref="T:DryIoc.Scope"/> returned by reuse.</summary>
            <param name="request">Request for service to resolve.</param> <returns>Created expression.</returns>
        </member>
        <member name="T:DryIoc.ExpressionFactory">
            <summary>Creates service expression using client provided expression factory delegate.</summary>
        </member>
        <member name="M:DryIoc.ExpressionFactory.#ctor(System.Func{DryIoc.Request,System.Linq.Expressions.Expression},DryIoc.IReuse,DryIoc.Setup)">
            <summary>Wraps provided delegate into factory.</summary>
            <param name="getServiceExpression">Delegate that will be used internally to create service expression.</param>
            <param name="reuse">(optional) Reuse.</param> <param name="setup">(optional) Setup.</param>
        </member>
        <member name="M:DryIoc.ExpressionFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>Creates service expression using wrapped delegate.</summary>
            <param name="request">Request to resolve.</param> <returns>Expression returned by stored delegate.</returns>
        </member>
        <member name="T:DryIoc.InstanceFactory">
            <summary>Obsolete: replaced with UsedInstanceFactory.</summary>
        </member>
        <member name="P:DryIoc.InstanceFactory.ImplementationType">
            <summary>Instance type, or null for null instance.</summary>
        </member>
        <member name="M:DryIoc.InstanceFactory.#ctor(System.Object,DryIoc.IReuse,DryIoc.Setup)">
            <summary>Creates factory wrapping provided instance.</summary>
            <param name="instance">Instance to register.</param>
            <param name="reuse"></param> <param name="setup"></param>
        </member>
        <member name="M:DryIoc.InstanceFactory.ReplaceInstance(System.Object)">
            <summary>Replaces current instance with new one.</summary> <param name="newInstance"></param>
        </member>
        <member name="M:DryIoc.InstanceFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>The method should not be really called. That's why it returns exception throwing expression.</summary>
            <param name="request">Context</param> <returns>Expression throwing exception.</returns>
        </member>
        <member name="M:DryIoc.InstanceFactory.ApplyReuse(System.Linq.Expressions.Expression,DryIoc.IReuse,System.Boolean,DryIoc.Request)">
            <summary>Puts instance directly to available scope.</summary>
        </member>
        <member name="T:DryIoc.DelegateFactory">
            <summary>This factory is the thin wrapper for user provided delegate
            and where possible it uses delegate directly: without converting it to expression.</summary>
        </member>
        <member name="P:DryIoc.DelegateFactory.ImplementationType">
            <summary>Non-abstract closed implementation type.</summary>
        </member>
        <member name="M:DryIoc.DelegateFactory.#ctor(System.Func{DryIoc.IResolver,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Type)">
            <summary>Creates factory by providing:</summary>
            <param name="factoryDelegate">Specified service creation delegate.</param>
            <param name="reuse">(optional) Reuse behavior for created service.</param>
            <param name="setup">(optional) Additional settings.</param>
            <param name="knownImplementationType">(optional) Implementation type if known, e.g. when registering existing instance.</param>
        </member>
        <member name="M:DryIoc.DelegateFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>Create expression by wrapping call to stored delegate with provided request.</summary>
            <param name="request">Request to resolve. It will be stored in resolution state to be passed to delegate on actual resolve.</param>
            <returns>Created delegate call expression.</returns>
        </member>
        <member name="M:DryIoc.DelegateFactory.GetDelegateOrDefault(DryIoc.Request)">
            <summary>If possible returns delegate directly, without creating expression trees, just wrapped in <see cref="T:DryIoc.FactoryDelegate"/>.
            If decorator found for request then factory fall-backs to expression creation.</summary>
            <param name="request">Request to resolve.</param>
            <returns>Factory delegate directly calling wrapped delegate, or invoking expression if decorated.</returns>
        </member>
        <member name="T:DryIoc.CreateScopedValue">
            <summary>Should return value stored in scope.</summary>
        </member>
        <member name="T:DryIoc.IScope">
            <summary>Lazy object storage that will create object with provided factory on first access,
            then will be returning the same object for subsequent access.</summary>
        </member>
        <member name="P:DryIoc.IScope.Parent">
            <summary>Parent scope in scope stack. Null for root scope.</summary>
        </member>
        <member name="P:DryIoc.IScope.Name">
            <summary>Optional name object associated with scope.</summary>
        </member>
        <member name="M:DryIoc.IScope.GetOrAdd(System.Int32,DryIoc.CreateScopedValue)">
            <summary>Creates, stores, and returns stored object.</summary>
            <param name="id">Unique ID to find created object in subsequent calls.</param>
            <param name="createValue">Delegate to create object. It will be used immediately, and reference to delegate will not be stored.</param>
            <returns>Created and stored object.</returns>
            <remarks>Scope does not store <paramref name="createValue"/> (no memory leak here),
            it stores only result of <paramref name="createValue"/> call.</remarks>
        </member>
        <member name="M:DryIoc.IScope.SetOrAdd(System.Int32,System.Object)">
            <summary>Sets (replaces) value at specified id, or adds value if no existing id found.</summary>
            <param name="id">To set value at.</param> <param name="item">Value to set.</param>
        </member>
        <member name="M:DryIoc.IScope.GetScopedItemIdOrSelf(System.Int32)">
            <summary>Creates id/index for new item to be stored in scope.
            If separate index is not supported then just returns back passed <paramref name="externalId"/>.</summary>
            <param name="externalId">Id to be mapped to new item id/index</param>
            <returns>New it/index or just passed <paramref name="externalId"/></returns>
        </member>
        <member name="T:DryIoc.Scope">
            <summary>Scope implementation which will dispose stored <see cref="T:System.IDisposable"/> items on its own dispose.
            Locking is used internally to ensure that object factory called only once.</summary>
        </member>
        <member name="P:DryIoc.Scope.Parent">
            <summary>Parent scope in scope stack. Null for root scope.</summary>
        </member>
        <member name="P:DryIoc.Scope.Name">
            <summary>Optional name object associated with scope.</summary>
        </member>
        <member name="M:DryIoc.Scope.#ctor(DryIoc.IScope,System.Object)">
            <summary>Create scope with optional parent and name.</summary>
            <param name="parent">Parent in scope stack.</param> <param name="name">Associated name object.</param>
        </member>
        <member name="M:DryIoc.Scope.GetScopedItemIdOrSelf(System.Int32)">
            <summary>Just returns back <paramref name="externalId"/> without any changes.</summary>
            <param name="externalId">Id will be returned back.</param> <returns><paramref name="externalId"/>.</returns>
        </member>
        <member name="M:DryIoc.Scope.GetOrAdd(System.Int32,DryIoc.CreateScopedValue)">
            <summary><see cref="M:DryIoc.IScope.GetOrAdd(System.Int32,DryIoc.CreateScopedValue)"/> for description.
            Will throw <see cref="T:DryIoc.ContainerException"/> if scope is disposed.</summary>
            <param name="id">Unique ID to find created object in subsequent calls.</param>
            <param name="createValue">Delegate to create object. It will be used immediately, and reference to delegate will Not be stored.</param>
            <returns>Created and stored object.</returns>
            <exception cref="T:DryIoc.ContainerException">if scope is disposed.</exception>
        </member>
        <member name="M:DryIoc.Scope.SetOrAdd(System.Int32,System.Object)">
            <summary>Sets (replaces) value at specified id, or adds value if no existing id found.</summary>
            <param name="id">To set value at.</param> <param name="item">Value to set.</param>
        </member>
        <member name="M:DryIoc.Scope.Dispose">
            <summary>Disposes all stored <see cref="T:System.IDisposable"/> objects and nullifies object storage.</summary>
            <remarks>If item disposal throws exception, then it won't be propagated outside,
            so the rest of the items could be disposed.</remarks>
        </member>
        <member name="M:DryIoc.Scope.ToString">
            <summary>Prints scope info (name and parent) to string for debug purposes.</summary>
            <returns>String representation.</returns>
        </member>
        <member name="T:DryIoc.SingletonScope">
            <summary>Different from <see cref="T:DryIoc.Scope"/> so that uses single array of items for fast access.
            The array structure is:
            items[0] is reserved for storing object[][] buckets.
            items[1-BucketSize] are used for storing actual singletons up to (BucketSize-1) index
            Buckets structure is variable number of object[BucketSize] buckets used to storing items with index >= BucketSize.
            The structure allows very fast access to up to <see cref="F:DryIoc.SingletonScope.BucketSize"/> singletons - it just array access: items[itemIndex]
            For further indexes it is a fast O(1) access: ((object[][])items[i])[i / BucketSize - 1][i % BucketSize]
            </summary>
        </member>
        <member name="P:DryIoc.SingletonScope.Parent">
            <summary>Parent scope in scope stack. Null for root scope.</summary>
        </member>
        <member name="P:DryIoc.SingletonScope.Name">
            <summary>Optional name object associated with scope.</summary>
        </member>
        <member name="F:DryIoc.SingletonScope.BucketSize">
            <summary>Amount of items in item array.</summary>
        </member>
        <member name="P:DryIoc.SingletonScope.IsDisposed">
            <summary>Returns true if scope was disposed.</summary>
        </member>
        <member name="M:DryIoc.SingletonScope.#ctor(DryIoc.IScope,System.Object)">
            <summary>Creates scope.</summary>
            <param name="parent">Parent in scope stack.</param> <param name="name">Associated name object.</param>
        </member>
        <member name="M:DryIoc.SingletonScope.GetScopedItemIdOrSelf(System.Int32)">
            <summary>Adds mapping between provide id and index for new stored item. Returns index.</summary>
            <param name="externalId">External id mapped to internal index.</param>
            <returns>Already mapped index, or newly created.</returns>
        </member>
        <member name="M:DryIoc.SingletonScope.GetOrAdd(System.Int32,DryIoc.CreateScopedValue)">
            <summary><see cref="M:DryIoc.IScope.GetOrAdd(System.Int32,DryIoc.CreateScopedValue)"/> for description.
            Will throw <see cref="T:DryIoc.ContainerException"/> if scope is disposed.</summary>
            <param name="id">Unique ID to find created object in subsequent calls.</param>
            <param name="createValue">Delegate to create object. It will be used immediately, and reference to delegate will Not be stored.</param>
            <returns>Created and stored object.</returns>
            <exception cref="T:DryIoc.ContainerException">if scope is disposed.</exception>
        </member>
        <member name="M:DryIoc.SingletonScope.SetOrAdd(System.Int32,System.Object)">
            <summary>Sets (replaces) value at specified id, or adds value if no existing id found.</summary>
            <param name="id">To set value at.</param> <param name="item">Value to set.</param>
        </member>
        <member name="M:DryIoc.SingletonScope.Dispose">
            <summary>Disposes all stored <see cref="T:System.IDisposable"/> objects and nullifies object storage.</summary>
            <remarks>If item disposal throws exception, then it won't be propagated outside, so the rest of the items could be disposed.</remarks>
        </member>
        <member name="F:DryIoc.SingletonScope.Items">
            <summary>value at 0 index is reserved for [][] structure to accommodate more values</summary>
        </member>
        <member name="T:DryIoc.SetCurrentScopeHandler">
            <summary>Delegate to get new scope from old/existing current scope.</summary>
            <param name="oldScope">Old/existing scope to change.</param>
            <returns>New scope or old if do not want to change current scope.</returns>
        </member>
        <member name="T:DryIoc.IScopeContext">
            <summary>Provides ambient current scope and optionally scope storage for container,
            examples are HttpContext storage, Execution context, Thread local.</summary>
        </member>
        <member name="P:DryIoc.IScopeContext.RootScopeName">
            <summary>Name associated with context root scope - so the reuse may find scope context.</summary>
        </member>
        <member name="M:DryIoc.IScopeContext.GetCurrentOrDefault">
            <summary>Returns current scope or null if no ambient scope available at the moment.</summary>
            <returns>Current scope or null.</returns>
        </member>
        <member name="M:DryIoc.IScopeContext.SetCurrent(DryIoc.SetCurrentScopeHandler)">
            <summary>Changes current scope using provided delegate. Delegate receives current scope as input and
            should return new current scope.</summary>
            <param name="setCurrentScope">Delegate to change the scope.</param>
            <remarks>Important: <paramref name="setCurrentScope"/> may be called multiple times in concurrent environment.
            Make it predictable by removing any side effects.</remarks>
            <returns>New current scope. So it is convenient to use method in "using (var newScope = ctx.SetCurrent(...))".</returns>
        </member>
        <member name="T:DryIoc.ThreadScopeContext">
            <summary>Tracks one current scope per thread, so the current scope in different tread would be different or null,
            if not yet tracked. Context actually stores scope references internally, so it should be disposed to free them.</summary>
        </member>
        <member name="F:DryIoc.ThreadScopeContext.ScopeContextName">
            <summary>Provides static name for context. It is OK because its constant.</summary>
        </member>
        <member name="P:DryIoc.ThreadScopeContext.RootScopeName">
            <summary>Key to identify context.</summary>
        </member>
        <member name="M:DryIoc.ThreadScopeContext.GetCurrentOrDefault">
            <summary>Returns current scope in calling Thread or null, if no scope tracked.</summary>
            <returns>Found scope or null.</returns>
        </member>
        <member name="M:DryIoc.ThreadScopeContext.SetCurrent(DryIoc.SetCurrentScopeHandler)">
            <summary>Change current scope for the calling Thread.</summary>
            <param name="setCurrentScope">Delegate to change the scope given current one (or null).</param>
            <remarks>Important: <paramref name="setCurrentScope"/> may be called multiple times in concurrent environment.
            Make it predictable by removing any side effects.</remarks>
        </member>
        <member name="M:DryIoc.ThreadScopeContext.Dispose">
            <summary>Disposed all stored/tracked scopes and empties internal scope storage.</summary>
        </member>
        <member name="T:DryIoc.IReuse">
            <summary>Obsolete: until v3 replaced by <see cref="T:DryIoc.IReuseV3"/>.</summary>
        </member>
        <member name="P:DryIoc.IReuse.Lifespan">
            <summary>Relative to other reuses lifespan value.</summary>
        </member>
        <member name="M:DryIoc.IReuse.GetScopeOrDefault(DryIoc.Request)">
            <summary>Locates or creates scope to store reused service objects.</summary>
            <param name="request">Request to get context information or for example store something in resolution state.</param>
            <returns>Located scope.</returns>
        </member>
        <member name="M:DryIoc.IReuse.GetScopeExpression(DryIoc.Request)">
            <summary>ObsoIReuseV3.ApplyApply"/> instead.</summary>
        </member>
        <member name="M:DryIoc.IReuse.GetScopedItemIdOrSelf(System.Int32,DryIoc.Request)">
            <summary>Returns special id/index to lookup scoped item, or original passed factory id otherwise.</summary>
            <param name="factoryID">Id to map to item id/index.</param> <param name="request">Context to get access to scope.</param>
            <returns>id/index or source factory id.</returns>
        </member>
        <member name="T:DryIoc.IReuseV3">
            <summary>Simplified scope agnostic reuse abstraction. More easy to implement,
             and more powerful as can be based on other storage beside reuse.</summary>
        </member>
        <member name="P:DryIoc.IReuseV3.Lifespan">
            <summary>Relative to other reuses lifespan value.</summary>
        </member>
        <member name="M:DryIoc.IReuseV3.Apply(DryIoc.Request,System.Boolean,System.Linq.Expressions.Expression)">
            <summary>Returns composed expression.</summary>
            <param name="request">info</param>
            <param name="trackTransientDisposable">Indicates that item should be tracked.</param>
            <param name="createItemExpr">Service creation expression</param>
            <returns>Subject</returns>
        </member>
        <member name="M:DryIoc.IReuseV3.CanApply(DryIoc.Request)">
            <summary>Returns true if reuse can be applied: may check if scope or other reused item storage is present.</summary>
            <param name="request">Service request.</param> <returns>Check result.</returns>
        </member>
        <member name="T:DryIoc.SingletonReuse">
            <summary>Returns container bound scope for storing singleton objects.</summary>
        </member>
        <member name="P:DryIoc.SingletonReuse.Lifespan">
            <summary>Relative to other reuses lifespan value.</summary>
        </member>
        <member name="M:DryIoc.SingletonReuse.Apply(DryIoc.Request,System.Boolean,System.Linq.Expressions.Expression)">
            <summary>Returns expression call to GetOrAddItem.</summary>
        </member>
        <member name="M:DryIoc.SingletonReuse.CanApply(DryIoc.Request)">
            <summary>Returns true because singleton is always available.</summary>
            <param name="request">_</param> <returns>True.</returns>
        </member>
        <member name="M:DryIoc.SingletonReuse.ToExpression(System.Func{System.Object,System.Linq.Expressions.Expression})">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.SingletonReuse.GetScopeOrDefault(DryIoc.Request)">
            <summary>Returns container bound Singleton scope.</summary>
            <param name="request">Request to get context information or for example store something in resolution state.</param>
            <returns>Container singleton scope.</returns>
        </member>
        <member name="M:DryIoc.SingletonReuse.GetScopeExpression(DryIoc.Request)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.SingletonReuse.GetScopedItemIdOrSelf(System.Int32,DryIoc.Request)">
            <summary>Returns index of new item in singleton scope.</summary>
            <param name="factoryID">Factory id to map to new item index.</param>
            <param name="request">Context to get singleton scope from.</param>
            <returns>Index in scope.</returns>
        </member>
        <member name="M:DryIoc.SingletonReuse.ToString">
            <summary>Pretty prints reuse name and lifespan</summary> <returns>Printed string.</returns>
        </member>
        <member name="T:DryIoc.CurrentScopeReuse">
            <summary>Returns container bound current scope created by <see cref="M:DryIoc.Container.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})"/> method.</summary>
            <remarks>It is the same as Singleton scope if container was not created by <see cref="M:DryIoc.Container.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})"/>.</remarks>
        </member>
        <member name="F:DryIoc.CurrentScopeReuse.Name">
            <summary>Name to find current scope or parent with equal name.</summary>
        </member>
        <member name="P:DryIoc.CurrentScopeReuse.Lifespan">
            <summary>Relative to other reuses lifespan value.</summary>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.#ctor(System.Object)">
            <summary>Creates reuse optionally specifying its name.</summary>
            <param name="name">(optional) Used to find matching current scope or parent.</param>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.GetOrAddItemOrDefault(DryIoc.IScopeAccess,System.Object,System.Boolean,System.Int32,DryIoc.CreateScopedValue)">
            <summary>Returns item from current scope with specified name.</summary>
            <param name="scopes">Container scopes to select from.</param>
            <param name="scopeName">scope name to look up.</param>
            <param name="throwIfNoScopeFound">Specifies to throw if scope with the <paramref name="scopeName"/> is not found.</param>
            <param name="itemId">Scoped item ID for lookup.</param>
            <param name="createValue">Delegate for creating the item.</param>
            <returns>Reused item.</returns>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.Apply(DryIoc.Request,System.Boolean,System.Linq.Expressions.Expression)">
            <summary>Returns expression call to <see cref="M:DryIoc.CurrentScopeReuse.GetOrAddItemOrDefault(DryIoc.IScopeAccess,System.Object,System.Boolean,System.Int32,DryIoc.CreateScopedValue)"/>.</summary>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.CanApply(DryIoc.Request)">
            <summary>Returns true if scope is open and the name is matching with reuse <see cref="F:DryIoc.CurrentScopeReuse.Name"/>.</summary>
            <param name="request">Service request.</param> <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.ToExpression(System.Func{System.Object,System.Linq.Expressions.Expression})">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.GetScopeOrDefault(DryIoc.Request)">
            <summary>Returns container current scope or if <see cref="F:DryIoc.CurrentScopeReuse.Name"/> specified: current scope or its parent with corresponding name.</summary>
            <param name="request">Request to get context information or for example store something in resolution state.</param>
            <returns>Found current scope or its parent.</returns>
            <exception cref="T:DryIoc.ContainerException">with the code <see cref="F:DryIoc.Error.NoMatchedScopeFound"/> if <see cref="F:DryIoc.CurrentScopeReuse.Name"/> specified but
            no matching scope or its parent found.</exception>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.GetScopeExpression(DryIoc.Request)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.GetScopedItemIdOrSelf(System.Int32,DryIoc.Request)">
            <summary>Asks the scope to convert factory ID into internal representation and returns it.
            If scope is not available then return passed factory ID.</summary>
            <param name="factoryID">Input factory ID.</param> <param name="request">Used to get scope back.</param>
            <returns>Scope mapping of factory ID or passed factory ID without changes if scope is not available.</returns>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.ToString">
            <summary>Pretty prints reuse to string.</summary> <returns>Reuse string.</returns>
        </member>
        <member name="T:DryIoc.ResolutionScopeReuse">
            <summary>Represents services created once per resolution root (when some of Resolve methods called).</summary>
            <remarks>Scope is created only if accessed to not waste memory.</remarks>
        </member>
        <member name="P:DryIoc.ResolutionScopeReuse.Lifespan">
            <summary>Relative to other reuses lifespan value.</summary>
        </member>
        <member name="F:DryIoc.ResolutionScopeReuse.AssignableFromServiceType">
            <summary>Indicates consumer with assignable service type that defines resolution scope.</summary>
        </member>
        <member name="F:DryIoc.ResolutionScopeReuse.ServiceKey">
            <summary>Indicates service key of the consumer that defines resolution scope.</summary>
        </member>
        <member name="F:DryIoc.ResolutionScopeReuse.Outermost">
            <summary>When set indicates to find the outermost matching consumer with resolution scope,
            otherwise nearest consumer scope will be used.</summary>
        </member>
        <member name="M:DryIoc.ResolutionScopeReuse.#ctor(System.Type,System.Object,System.Boolean)">
            <summary>Creates new resolution scope reuse with specified type and key.</summary>
            <param name="assignableFromServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="outermost">(optional)</param>
        </member>
        <member name="M:DryIoc.ResolutionScopeReuse.Apply(DryIoc.Request,System.Boolean,System.Linq.Expressions.Expression)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.ResolutionScopeReuse.CanApply(DryIoc.Request)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.ResolutionScopeReuse.ToExpression(System.Func{System.Object,System.Linq.Expressions.Expression})">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.ResolutionScopeReuse.GetScopeOrDefault(DryIoc.Request)">
            <summary>Creates or returns already created resolution root scope.</summary>
            <param name="request">Request to get context information or for example store something in resolution state.</param>
            <returns>Created or existing scope.</returns>
        </member>
        <member name="M:DryIoc.ResolutionScopeReuse.GetScopeExpression(DryIoc.Request)">
            <summary>Returns <see cref="M:DryIoc.IScopeAccess.GetMatchingResolutionScope(DryIoc.IScope,System.Type,System.Object,System.Boolean,System.Boolean)"/> method call expression.</summary>
            <param name="request">Request to get context information or for example store something in resolution state.</param>
            <returns>Method call expression returning existing or newly created resolution scope.</returns>
        </member>
        <member name="M:DryIoc.ResolutionScopeReuse.GetScopedItemIdOrSelf(System.Int32,DryIoc.Request)">
            <summary>Just returns back passed id without changes.</summary>
            <param name="factoryID">Id to return back.</param> <param name="request">Ignored.</param>
            <returns><paramref name="factoryID"/></returns>
        </member>
        <member name="M:DryIoc.ResolutionScopeReuse.ToString">
            <summary>Pretty prints reuse name and lifespan</summary> <returns>Printed string.</returns>
        </member>
        <member name="T:DryIoc.Reuse">
            <summary>Specifies pre-defined reuse behaviors supported by container:
            used when registering services into container with <see cref="T:DryIoc.Registrator"/> methods.</summary>
        </member>
        <member name="F:DryIoc.Reuse.Transient">
            <summary>Synonym for absence of reuse.</summary>
        </member>
        <member name="F:DryIoc.Reuse.Singleton">
            <summary>Specifies to store single service instance per <see cref="T:DryIoc.Container"/>.</summary>
        </member>
        <member name="F:DryIoc.Reuse.InResolutionScope">
            <summary>Specifies to store single service instance per resolution root created by <see cref="T:DryIoc.Resolver"/> methods.</summary>
        </member>
        <member name="F:DryIoc.Reuse.InCurrentScope">
            <summary>Specifies to store single service instance per current/open scope created with <see cref="M:DryIoc.Container.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})"/>.</summary>
        </member>
        <member name="F:DryIoc.Reuse.Scoped">
            <summary>Same as InCurrentScope. From now on will be the default name, later the rest of scoped reuses will be renamed to ScopedTo.</summary>
        </member>
        <member name="F:DryIoc.Reuse.ScopedOrSingleton">
            <summary>The same as <see cref="F:DryIoc.Reuse.InCurrentScope"/> but if no open scope available will fallback to <see cref="F:DryIoc.Reuse.Singleton"/></summary>
            <remarks>The <see cref="F:DryIoc.Error.DependencyHasShorterReuseLifespan"/> is applied the same way as for <see cref="F:DryIoc.Reuse.InCurrentScope"/> reuse.</remarks>
        </member>
        <member name="M:DryIoc.Reuse.InCurrentNamedScope(System.Object)">
            <summary>Returns current scope reuse with specific name to match with scope.
            If name is not specified then function returns <see cref="F:DryIoc.Reuse.InCurrentScope"/>.</summary>
            <param name="name">(optional) Name to match with scope.</param>
            <returns>Created current scope reuse.</returns>
        </member>
        <member name="M:DryIoc.Reuse.InResolutionScopeOf(System.Type,System.Object,System.Boolean)">
            <summary>Creates reuse to search for <paramref name="assignableFromServiceType"/> and <paramref name="serviceKey"/>
            in existing resolution scope hierarchy. If parameters are not specified or null, then <see cref="F:DryIoc.Reuse.InResolutionScope"/> will be returned.</summary>
            <param name="assignableFromServiceType">(optional) To search for scope with service type assignable to type specified in parameter.</param>
            <param name="serviceKey">(optional) Search for specified key.</param>
            <param name="outermost">If true - commands to look for outermost match instead of nearest.</param>
            <returns>New reuse with specified parameters or <see cref="F:DryIoc.Reuse.InResolutionScope"/> if nothing specified.</returns>
        </member>
        <member name="M:DryIoc.Reuse.InResolutionScopeOf``1(System.Object,System.Boolean)">
            <summary>Creates reuse to search for <typeparamref name="TAssignableFromServiceType"/> and <paramref name="serviceKey"/>
            in existing resolution scope hierarchy.</summary>
            <typeparam name="TAssignableFromServiceType">To search for scope with service type assignable to type specified in parameter.</typeparam>
            <param name="serviceKey">(optional) Search for specified key.</param>
            <param name="outermost">If true - commands to look for outermost match instead of nearest.</param>
            <returns>New reuse with specified parameters.</returns>
        </member>
        <member name="F:DryIoc.Reuse.InThread">
            <summary>Ensuring single service instance per Thread.</summary>
        </member>
        <member name="F:DryIoc.Reuse.WebRequestScopeName">
            <summary>Special name that by convention recognized by <see cref="F:DryIoc.Reuse.InWebRequest"/>.</summary>
        </member>
        <member name="F:DryIoc.Reuse.InWebRequest">
            <summary>Web request is just convention for reuse in <see cref="M:DryIoc.Reuse.InCurrentNamedScope(System.Object)"/> with special name <see cref="F:DryIoc.Reuse.WebRequestScopeName"/>.</summary>
        </member>
        <member name="T:DryIoc.Reuse.TransientReuse">
            <summary>No-reuse</summary>
        </member>
        <member name="P:DryIoc.Reuse.TransientReuse.Lifespan">
            <summary>0 means no reused lifespan</summary>
        </member>
        <member name="M:DryIoc.Reuse.TransientReuse.Apply(DryIoc.Request,System.Boolean,System.Linq.Expressions.Expression)">
            <summary>returns source expression without modification</summary>
        </member>
        <member name="T:DryIoc.IfUnresolved">
            <summary>Policy to handle unresolved service.</summary>
        </member>
        <member name="F:DryIoc.IfUnresolved.Throw">
            <summary>Specifies to throw exception if no service found.</summary>
        </member>
        <member name="F:DryIoc.IfUnresolved.ReturnDefault">
            <summary>Specifies to return default value instead of throwing error.</summary>
        </member>
        <member name="T:DryIoc.RequestInfo">
            <summary>Dependency request path information.</summary>
        </member>
        <member name="F:DryIoc.RequestInfo.Empty">
            <summary>Represents an empty info.</summary>
        </member>
        <member name="F:DryIoc.RequestInfo.ParentOrWrapper">
            <summary>Parent request or null for root resolution request.</summary>
        </member>
        <member name="F:DryIoc.RequestInfo.ServiceInfo">
            <summary>Wraps the resolved service lookup details.</summary>
        </member>
        <member name="F:DryIoc.RequestInfo.FactoryID">
            <summary>Resolved factory ID, used to identify applied decorator.</summary>
        </member>
        <member name="F:DryIoc.RequestInfo.FactoryType">
            <summary>Type of factory: Service, Wrapper, or Decorator.</summary>
        </member>
        <member name="F:DryIoc.RequestInfo.ImplementationType">
            <summary>Service implementation type if known.</summary>
        </member>
        <member name="F:DryIoc.RequestInfo.Reuse">
            <summary>Service reuse.</summary>
        </member>
        <member name="F:DryIoc.RequestInfo.Flags">
            <summary>The options and check results propagated with request from <see cref="T:DryIoc.RequestFlags"/>.</summary>
        </member>
        <member name="F:DryIoc.RequestInfo.DecoratedFactoryID">
            <summary>ID of decorated factory in case of decorator factory type</summary>
        </member>
        <member name="P:DryIoc.RequestInfo.IsEmpty">
            <summary>Returns true for an empty request.</summary>
        </member>
        <member name="P:DryIoc.RequestInfo.IsResolutionRoot">
            <summary>Returns true if request is the first in a chain.</summary>
        </member>
        <member name="P:DryIoc.RequestInfo.Parent">
            <summary>Returns service parent skipping wrapper if any. To get immediate parent us <see cref="F:DryIoc.RequestInfo.ParentOrWrapper"/>.</summary>
        </member>
        <member name="P:DryIoc.RequestInfo.ServiceType">
            <summary>Requested service type.</summary>
        </member>
        <member name="P:DryIoc.RequestInfo.RequiredServiceType">
            <summary>Required service type if specified.</summary>
        </member>
        <member name="M:DryIoc.RequestInfo.GetActualServiceType">
            <summary>Returns <see cref="P:DryIoc.RequestInfo.RequiredServiceType"/> if it is specified and assignable to <see cref="P:DryIoc.RequestInfo.ServiceType"/>,
            otherwise returns <see cref="P:DryIoc.RequestInfo.ServiceType"/>.</summary>
            <returns>The type to be used for lookup in registry.</returns>
        </member>
        <member name="M:DryIoc.RequestInfo.GetKnownImplementationOrServiceType">
            <summary>Returns known implementation, or otherwise actual service type.</summary>
            <returns>The subject.</returns>
        </member>
        <member name="P:DryIoc.RequestInfo.IfUnresolved">
            <summary>Policy to deal with unresolved request.</summary>
        </member>
        <member name="P:DryIoc.RequestInfo.ServiceKey">
            <summary>Optional service key to identify service of the same type.</summary>
        </member>
        <member name="P:DryIoc.RequestInfo.MetadataKey">
            <summary>Metadata key to find in metadata dictionary in resolved service.</summary>
        </member>
        <member name="P:DryIoc.RequestInfo.Metadata">
            <summary>Metadata or the value (if key specified) to find in resolved service.</summary>
        </member>
        <member name="P:DryIoc.RequestInfo.ReuseLifespan">
            <summary>Relative number representing reuse lifespan.</summary>
        </member>
        <member name="M:DryIoc.RequestInfo.Push(System.Type,System.Int32,System.Type,DryIoc.IReuse)">
            <summary>Simplified version of Push with most common properties.</summary>
            <param name="serviceType"></param> <param name="factoryID"></param> <param name="implementationType"></param>
            <param name="reuse"></param> <returns>Created info chain to current (parent) info.</returns>
        </member>
        <member name="M:DryIoc.RequestInfo.Push(System.Type,System.Type,System.Object,System.Int32,DryIoc.FactoryType,System.Type,DryIoc.IReuse,DryIoc.RequestFlags)">
            <summary>Creates info by supplying all the properties and chaining it with current (parent) info.</summary>
            <param name="serviceType"></param> <param name="requiredServiceType"></param>
            <param name="serviceKey"></param> <param name="factoryType"></param> <param name="factoryID"></param>
            <param name="implementationType"></param> <param name="reuse"></param><param name="flags"></param>
            <returns>Created info chain to current (parent) info.</returns>
        </member>
        <member name="M:DryIoc.RequestInfo.Push(System.Type,System.Type,System.Object,DryIoc.IfUnresolved,System.Int32,DryIoc.FactoryType,System.Type,DryIoc.IReuse,DryIoc.RequestFlags)">
            <summary>Creates info by supplying all the properties and chaining it with current (parent) info.</summary>
            <param name="serviceType"></param> <param name="requiredServiceType"></param>
            <param name="serviceKey"></param> <param name="ifUnresolved"></param>
            <param name="factoryType"></param> <param name="factoryID"></param>
            <param name="implementationType"></param> <param name="reuse"></param>
            <param name="flags"></param>
            <returns>Created info chain to current (parent) info.</returns>
        </member>
        <member name="M:DryIoc.RequestInfo.Push(System.Type,System.Type,System.Object,System.String,System.Object,DryIoc.IfUnresolved,System.Int32,DryIoc.FactoryType,System.Type,DryIoc.IReuse,DryIoc.RequestFlags)">
            <summary>Creates info by supplying all the properties and chaining it with current (parent) info.</summary>
            <param name="serviceType"></param> <param name="requiredServiceType"></param>
            <param name="serviceKey"></param> <param name="metadataKey"></param><param name="metadata"></param>
            <param name="ifUnresolved"></param>
            <param name="factoryType"></param> <param name="factoryID"></param>
            <param name="implementationType"></param> <param name="reuse"></param>
            <param name="flags"></param>
            <returns>Created info chain to current (parent) info.</returns>
        </member>
        <member name="M:DryIoc.RequestInfo.Push(DryIoc.IServiceInfo,System.Int32,DryIoc.FactoryType,System.Type,DryIoc.IReuse,DryIoc.RequestFlags,System.Int32)">
            <summary>Creates info by supplying all the properties and chaining it with current (parent) info.</summary>
            <param name="serviceInfo"></param>
            <param name="factoryType">(optional)</param> <param name="factoryID">(optional)</param>
            <param name="implementationType">(optional)</param> <param name="reuse">(optional)</param>
            <param name="flags">(optional)</param>
            <param name="decoratedFactoryID">(optional)</param>
            <returns>Created info chain to current (parent) info.</returns>
        </member>
        <member name="M:DryIoc.RequestInfo.Enumerate">
            <summary>Returns all request until the root - parent is null.</summary>
            <returns>Requests from the last to first.</returns>
        </member>
        <member name="M:DryIoc.RequestInfo.PrintCurrent(System.Text.StringBuilder)">
            <summary>Prints request without parents.</summary>
            <param name="s">Where to print.</param><returns><paramref name="s"/> with appended info.</returns>
        </member>
        <member name="M:DryIoc.RequestInfo.Print(System.Text.StringBuilder)">
            <summary>Prints request with all its parents.</summary>
            <param name="s">Where to print.</param><returns><paramref name="s"/> with appended info.</returns>
        </member>
        <member name="M:DryIoc.RequestInfo.ToString">
            <summary>Prints request with all its parents to string.</summary> <returns>The string.</returns>
        </member>
        <member name="M:DryIoc.RequestInfo.Equals(System.Object)">
            <summary>Returns true if request info and passed object are equal, and their parents recursively are equal.</summary>
            <param name="obj"></param> <returns></returns>
        </member>
        <member name="M:DryIoc.RequestInfo.Equals(DryIoc.RequestInfo)">
            <summary>Returns true if request info and passed info are equal, and their parents recursively are equal.</summary>
            <param name="other"></param> <returns></returns>
        </member>
        <member name="M:DryIoc.RequestInfo.EqualsWithoutParent(DryIoc.RequestInfo)">
            <summary>Compares info's regarding properties but not their parents.</summary>
            <param name="other">Info to compare for equality.</param> <returns></returns>
        </member>
        <member name="M:DryIoc.RequestInfo.EqualsWithoutParent(DryIoc.Request)">
            <summary>Compares info's regarding properties but not their parents.</summary>
            <param name="other">Info to compare for equality.</param> <returns></returns>
        </member>
        <member name="M:DryIoc.RequestInfo.GetHashCode">
            <summary>Returns hash code combined from info fields plus its parent.</summary>
            <returns>Combined hash code.</returns>
        </member>
        <member name="T:DryIoc.IResolver">
            <summary>Declares minimal API for service resolution.
            The user friendly convenient methods are implemented as extension methods in <see cref="T:DryIoc.Resolver"/> class.</summary>
            <remarks>Resolve default and keyed is separated because of micro optimization for faster resolution.</remarks>
        </member>
        <member name="M:DryIoc.IResolver.Resolve(System.Type,System.Boolean)">
            <summary>Resolves default (non-keyed) service from container and returns created service object.</summary>
            <param name="serviceType">Service type to search and to return.</param>
            <param name="ifUnresolvedReturnDefault">Says what to do if service is unresolved.</param>
            <returns>Created service object or default based on <paramref name="ifUnresolvedReturnDefault"/> provided.</returns>
        </member>
        <member name="M:DryIoc.IResolver.Resolve(System.Type,System.Object,System.Boolean,System.Type,DryIoc.RequestInfo,DryIoc.IScope)">
            <summary>Resolves service from container and returns created service object.</summary>
            <param name="serviceType">Service type to search and to return.</param>
            <param name="serviceKey">Optional service key used for registering service.</param>
            <param name="ifUnresolvedReturnDefault">Says what to do if service is unresolved.</param>
            <param name="requiredServiceType">Actual registered service type to use instead of <paramref name="serviceType"/>,
                or wrapped type for generic wrappers.  The type should be assignable to return <paramref name="serviceType"/>.</param>
            <param name="preResolveParent">Dependency resolution path info.</param>
            <param name="scope">Propagated resolution scope.</param>
            <returns>Created service object or default based on <paramref name="ifUnresolvedReturnDefault"/> provided.</returns>
            <remarks>
            This method covers all possible resolution input parameters comparing to <see cref="M:DryIoc.IResolver.Resolve(System.Type,System.Boolean)"/>, and
            by specifying the same parameters as for <see cref="M:DryIoc.IResolver.Resolve(System.Type,System.Boolean)"/> should return the same result.
            </remarks>
        </member>
        <member name="M:DryIoc.IResolver.ResolveMany(System.Type,System.Object,System.Type,System.Object,System.Type,DryIoc.RequestInfo,DryIoc.IScope)">
            <summary>Resolves all services registered for specified <paramref name="serviceType"/>, or if not found returns
            empty enumerable. If <paramref name="serviceType"/> specified then returns only (single) service registered with
            this type. Excludes for result composite parent identified by <paramref name="compositeParentKey"/>.</summary>
            <param name="serviceType">Return type of an service item.</param>
            <param name="serviceKey">(optional) Resolve only single service registered with the key.</param>
            <param name="requiredServiceType">(optional) Actual registered service to search for.</param>
            <param name="compositeParentKey">OBSOLETE: Now I can use <paramref name="preResolveParent"/> to identify composite parent.</param>
            <param name="compositeParentRequiredType">OBSOLETE: Now I can use <paramref name="preResolveParent"/> to identify composite parent.</param>
            <param name="preResolveParent">Dependency resolution path info.</param>
            <param name="scope">propagated resolution scope, may be null.</param>
            <returns>Enumerable of found services or empty. Does Not throw if no service found.</returns>
        </member>
        <member name="T:DryIoc.IfAlreadyRegistered">
            <summary>Specifies options to handle situation when registered service is already present in the registry.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.AppendNotKeyed">
            <summary>Appends new default registration or throws registration with the same key.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.Throw">
            <summary>Throws if default or registration with the same key is already exist.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.Keep">
            <summary>Keeps old default or keyed registration ignoring new registration: ensures Register-Once semantics.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.Replace">
            <summary>Replaces old registration with new one.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.AppendNewImplementation">
            <summary>Adds the new implementation or null (Made.Of),
            otherwise keeps the previous registration of the same implementation type.</summary>
        </member>
        <member name="T:DryIoc.ServiceRegistrationInfo">
            <summary>Define registered service structure.</summary>
        </member>
        <member name="F:DryIoc.ServiceRegistrationInfo.ServiceType">
            <summary>Required service type.</summary>
        </member>
        <member name="F:DryIoc.ServiceRegistrationInfo.OptionalServiceKey">
            <summary>Is null single default service, or actual service key, or <see cref="T:DryIoc.DefaultKey"/> for multiple default services.</summary>
        </member>
        <member name="F:DryIoc.ServiceRegistrationInfo.Factory">
            <summary>Registered factory.</summary>
        </member>
        <member name="F:DryIoc.ServiceRegistrationInfo.FactoryRegistrationOrder">
            <summary>Provides registration order across all factory registrations in container.</summary>
            <remarks>May be repeated for factory registered with multiple services.</remarks>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.#ctor(DryIoc.Factory,System.Type,System.Object)">
            <summary>Creates info. Registration order is figured out automatically based on Factory.</summary>
            <param name="factory"></param> <param name="serviceType"></param> <param name="optionalServiceKey"></param>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.CompareTo(DryIoc.ServiceRegistrationInfo)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.ToString">
            <summary>Pretty-prints info to string.</summary> <returns>The string.</returns>
        </member>
        <member name="T:DryIoc.IRegistrator">
            <summary>Defines operations that for changing registry, and checking if something exist in registry.</summary>
        </member>
        <member name="M:DryIoc.IRegistrator.GetServiceRegistrations">
            <summary>Returns all registered service factories with their Type and optional Key.</summary>
            <returns>Existing registrations.</returns>
            <remarks>Decorator and Wrapper types are not included.</remarks>
        </member>
        <member name="M:DryIoc.IRegistrator.Register(DryIoc.Factory,System.Type,System.Object,DryIoc.IfAlreadyRegistered,System.Boolean)">
            <summary>Registers factory in registry with specified service type and key for lookup.
            Returns true if factory was added to registry, false otherwise. False may be in case of <see cref="F:DryIoc.IfAlreadyRegistered.Keep"/>
            setting and already existing factory</summary>
            <param name="factory">To register.</param>
            <param name="serviceType">Service type as unique key in registry for lookup.</param>
            <param name="serviceKey">Service key as complementary lookup for the same service type.</param>
            <param name="ifAlreadyRegistered">Policy how to deal with already registered factory with same service type and key.</param>
            <param name="isStaticallyChecked">Confirms that service and implementation types are statically checked by compiler.</param>
            <returns>True if factory was added to registry, false otherwise.
            False may be in case of <see cref="F:DryIoc.IfAlreadyRegistered.Keep"/> setting and already existing factory.</returns>
        </member>
        <member name="M:DryIoc.IRegistrator.IsRegistered(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Returns true if expected factory is registered with specified service key and type.</summary>
            <param name="serviceType">Type to lookup.</param>
            <param name="serviceKey">(optional) Identifies registration via service key.
            Not provided or <c>null</c> service key means to check the <paramref name="serviceType"/> alone with any service key.</param>
            <param name="factoryType">Expected factory type.</param>
            <param name="condition">Expected factory condition.</param>
            <returns>True if expected factory found in registry.</returns>
        </member>
        <member name="M:DryIoc.IRegistrator.Unregister(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Removes factory with specified service type and key from registry.</summary>
            <param name="serviceType">Type to lookup.</param>
            <param name="serviceKey">Key to lookup for the same type.</param>
            <param name="factoryType">Expected factory type.</param>
            <param name="condition">Expected factory condition.</param>
        </member>
        <member name="T:DryIoc.IScopeAccess">
            <summary>Provides access to scopes.</summary>
        </member>
        <member name="M:DryIoc.IScopeAccess.GetCurrentScope">
            <summary>Current scope.</summary>
        </member>
        <member name="M:DryIoc.IScopeAccess.GetCurrentNamedScope(System.Object,System.Boolean)">
            <summary>Gets current scope matching the <paramref name="name"/>.
            If name is null then current scope is returned, or if there is no current scope then exception thrown.</summary>
            <param name="name">May be null</param> <returns>Found scope or throws exception.</returns>
            <param name="throwIfNotFound">Says to throw if no scope found.</param>
        </member>
        <member name="M:DryIoc.IScopeAccess.GetOrCreateResolutionScope(DryIoc.IScope@,System.Type,System.Object)">
            <summary>Check if scope is not null, then just returns it, otherwise will create and return it.</summary>
            <param name="scope">May be null scope.</param>
            <param name="serviceType">Marking scope with resolved service type.</param>
            <param name="serviceKey">Marking scope with resolved service key.</param>
            <returns>Input <paramref name="scope"/> ensuring it is not null.</returns>
        </member>
        <member name="M:DryIoc.IScopeAccess.GetOrNewResolutionScope(DryIoc.IScope,System.Type,System.Object)">
            <summary>Check if scope is not null, then just returns it, otherwise will create and return it.</summary>
            <param name="scope">May be null scope.</param>
            <param name="serviceType">Marking scope with resolved service type.</param>
            <param name="serviceKey">Marking scope with resolved service key.</param>
            <returns>Input <paramref name="scope"/> ensuring it is not null.</returns>
        </member>
        <member name="M:DryIoc.IScopeAccess.GetMatchingResolutionScope(DryIoc.IScope,System.Type,System.Object,System.Boolean,System.Boolean)">
            <summary>If both <paramref name="assignableFromServiceType"/> and <paramref name="serviceKey"/> are null,
            then returns input <paramref name="scope"/>.
            Otherwise searches scope hierarchy to find first scope with: Type assignable <paramref name="assignableFromServiceType"/> and
            Key equal to <paramref name="serviceKey"/>.</summary>
            <param name="scope">Scope to start matching with Type and Key specified.</param>
            <param name="assignableFromServiceType">Type to match.</param> <param name="serviceKey">Key to match.</param>
            <param name="outermost">If true - commands to look for outermost match instead of nearest.</param>
            <param name="throwIfNotFound">Says to throw if no scope found.</param>
        </member>
        <member name="T:DryIoc.IContainer">
            <summary>Exposes operations required for internal registry access.
            That's why most of them are implemented explicitly by <see cref="T:DryIoc.Container"/>.</summary>
        </member>
        <member name="P:DryIoc.IContainer.ContainerWeakRef">
            <summary>Self weak reference, with readable message when container is GCed/Disposed.</summary>
        </member>
        <member name="P:DryIoc.IContainer.Rules">
            <summary>Rules for defining resolution/registration behavior throughout container.</summary>
        </member>
        <member name="P:DryIoc.IContainer.EmptyRequest">
            <summary>Empty request bound to container. All other requests are created by pushing to empty request.</summary>
        </member>
        <member name="P:DryIoc.IContainer.ResolutionStateCache">
            <summary>State item objects which may include: singleton instances for fast access, reuses, reuse wrappers, factory delegates, etc.</summary>
        </member>
        <member name="M:DryIoc.IContainer.With(System.Func{DryIoc.Rules,DryIoc.Rules},DryIoc.IScopeContext)">
            <summary>Copies all of container state except Cache and specifies new rules.</summary>
            <param name="configure">(optional) Configure rules, if not specified then uses Rules from current container.</param>
            <param name="scopeContext">(optional) New scope context, if not specified then uses context from current container.</param>
            <returns>New container.</returns>
        </member>
        <member name="M:DryIoc.IContainer.WithNoMoreRegistrationAllowed(System.Boolean)">
            <summary>Produces new container which prevents any further registrations.</summary>
            <param name="ignoreInsteadOfThrow">(optional)Controls what to do with registrations: ignore or throw exception.
            Throws exception by default.</param>
            <returns>New container preserving all current container state but disallowing registrations.</returns>
        </member>
        <member name="M:DryIoc.IContainer.WithoutCache">
            <summary>Returns new container with all expression, delegate, items cache removed/reset.
            It will preserve resolved services in Singleton/Current scope.</summary>
            <returns>New container with empty cache.</returns>
        </member>
        <member name="M:DryIoc.IContainer.WithoutSingletonsAndCache">
            <summary>Creates new container with whole state shared with original except singletons.</summary>
            <returns>New container with empty Singleton Scope.</returns>
        </member>
        <member name="M:DryIoc.IContainer.WithRegistrationsCopy(System.Boolean)">
            <summary>Shares all parts with original container But copies registration, so the new registration
            won't be visible in original. Registrations include decorators and wrappers as well.</summary>
            <param name="preserveCache">(optional) If set preserves cache if you know what to do.</param>
            <returns>New container with copy of all registrations.</returns>
        </member>
        <member name="P:DryIoc.IContainer.ScopeContext">
            <summary>Returns scope context associated with container.</summary>
        </member>
        <member name="M:DryIoc.IContainer.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})">
            <summary>Creates new container with new opened scope, with shared registrations, singletons and resolutions cache.
            If container uses ambient scope context, then this method sets new opened scope as current scope in the context.
            In case of previous open scope, new open scope references old one as a parent.
            </summary>
            <param name="name">(optional) Name for opened scope to allow reuse to identify the scope.</param>
            <param name="configure">(optional) Configure rules, if not specified then uses Rules from current container.</param>
            <returns>New container with different current scope.</returns>
            <example><code lang="cs"><![CDATA[
            using (var scoped = container.OpenScope())
            {
                var handler = scoped.Resolve<IHandler>();
                handler.Handle(data);
            }
            ]]></code></example>
        </member>
        <member name="M:DryIoc.IContainer.CreateFacade">
            <summary>Creates container (facade) that fallbacks to this container for unresolved services.
            Facade shares rules with this container, everything else is its own.
            It could be used for instance to create Test facade over original container with replacing some services with test ones.</summary>
            <remarks>Singletons from container are not reused by facade, to achieve that rather use <see cref="M:DryIoc.IContainer.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})"/> with <see cref="F:DryIoc.Reuse.InCurrentScope"/>.</remarks>
            <returns>New facade container.</returns>
        </member>
        <member name="M:DryIoc.IContainer.ResolveFactory(DryIoc.Request)">
            <summary>Searches for requested factory in registry, and then using <see cref="P:DryIoc.Rules.UnknownServiceResolvers"/>.</summary>
            <param name="request">Factory request.</param>
            <returns>Found factory, otherwise null if <see cref="P:DryIoc.Request.IfUnresolved"/> is set to <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetServiceFactoryOrDefault(DryIoc.Request)">
            <summary>Searches for registered service factory and returns it, or null if not found.
            Will use <see cref="P:DryIoc.Rules.FactorySelector"/> if specified.</summary>
            <param name="request">Factory request.</param>
            <returns>Found factory or null.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetAllServiceFactories(System.Type,System.Boolean)">
            <summary>Finds all registered default and keyed service factories and returns them.
            It skips decorators and wrappers.</summary>
            <param name="serviceType">Service type to look for, may be open-generic type too.</param>
            <param name="bothClosedAndOpenGenerics">(optional) For generic serviceType instructs to look for
            both closed and open-generic registrations.</param>
            <returns>Enumerable of found pairs.</returns>
            <remarks>Returned Key item should not be null - it should be <see cref="F:DryIoc.DefaultKey.Value"/>.</remarks>
        </member>
        <member name="M:DryIoc.IContainer.GetWrapperFactoryOrDefault(System.Type)">
            <summary>Searches for registered wrapper factory and returns it, or null if not found.</summary>
            <param name="serviceType">Service type to look for.</param> <returns>Found wrapper factory or null.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetDecoratorFactoriesOrDefault(System.Type)">
            <summary>Returns all decorators registered for the service type.</summary> <returns>Decorator factories.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetDecoratorExpressionOrDefault(DryIoc.Request)">
            <summary>Creates decorator expression: it could be either Func{TService,TService},
            or service expression for replacing decorators.</summary>
            <param name="request">Decorated service request.</param>
            <returns>Decorator expression.</returns>
        </member>
        <member name="M:DryIoc.IContainer.InjectPropertiesAndFields(System.Object,DryIoc.PropertiesAndFieldsSelector)">
            <summary>For given instance resolves and sets properties and fields.</summary>
            <param name="instance">Service instance with properties to resolve and initialize.</param>
            <param name="propertiesAndFields">(optional) Function to select properties and fields, overrides all other rules if specified.</param>
            <returns>Instance with assigned properties and fields.</returns>
            <remarks>Different Rules could be combined together using <see cref="M:DryIoc.PropertiesAndFields.OverrideWith(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)"/> method.</remarks>
        </member>
        <member name="M:DryIoc.IContainer.GetWrappedType(System.Type,System.Type)">
            <summary>If <paramref name="serviceType"/> is generic type then this method checks if the type registered as generic wrapper,
            and recursively unwraps and returns its type argument. This type argument is the actual service type we want to find.
            Otherwise, method returns the input <paramref name="serviceType"/>.</summary>
            <param name="serviceType">Type to unwrap. Method will return early if type is not generic.</param>
            <param name="requiredServiceType">Required service type or null if don't care.</param>
            <returns>Unwrapped service type in case it corresponds to registered generic wrapper, or input type in all other cases.</returns>
        </member>
        <member name="M:DryIoc.IContainer.CacheFactoryExpression(System.Int32,System.Linq.Expressions.Expression)">
            <summary>Adds factory expression to cache identified by factory ID (<see cref="P:DryIoc.Factory.FactoryID"/>).</summary>
            <param name="factoryID">Key in cache.</param>
            <param name="factoryExpression">Value to cache.</param>
        </member>
        <member name="M:DryIoc.IContainer.GetCachedFactoryExpressionOrDefault(System.Int32)">
            <summary>Searches and returns cached factory expression, or null if not found.</summary>
            <param name="factoryID">Factory ID to lookup by.</param> <returns>Found expression or null.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetOrAddStateItemExpression(System.Object,System.Type,System.Boolean)">
            <summary>Converts known items into custom expression or wraps in <see cref="T:System.Linq.Expressions.ConstantExpression"/>.</summary>
            <param name="item">Item to convert.</param>
            <param name="itemType">(optional) Type of item, otherwise item <see cref="M:System.Object.GetType"/>.</param>
            <param name="throwIfStateRequired">(optional) Throws for non-primitive and not-recognized items,
            identifying that result expression require run-time state. For compiled expression it means closure in lambda delegate.</param>
            <returns>Returns constant or state access expression for added items.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetOrAddStateItem(System.Object)">
            <summary>Obsolete: Please don't use. Will be removed in V3.</summary>
        </member>
        <member name="T:DryIoc.LazyEnumerable`1">
            <summary>Resolves all registered services of <typeparamref name="TService"/> type on demand,
            when enumerator <see cref="M:System.Collections.IEnumerator.MoveNext"/> called. If service type is not found, empty returned.</summary>
            <typeparam name="TService">Service type to resolve.</typeparam>
        </member>
        <member name="F:DryIoc.LazyEnumerable`1.Items">
            <summary>Exposes internal items enumerable.</summary>
        </member>
        <member name="M:DryIoc.LazyEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Wraps lazy resolved items.</summary> <param name="items">Lazy resolved items.</param>
        </member>
        <member name="M:DryIoc.LazyEnumerable`1.GetEnumerator">
            <summary>Return items enumerator.</summary> <returns>items enumerator.</returns>
        </member>
        <member name="T:DryIoc.Meta`2">
            <summary>Wrapper type to box service with associated arbitrary metadata object.</summary>
            <typeparam name="T">Service type.</typeparam>
            <typeparam name="TMetadata">Arbitrary metadata object type.</typeparam>
        </member>
        <member name="F:DryIoc.Meta`2.Value">
            <summary>Value or object with associated metadata.</summary>
        </member>
        <member name="F:DryIoc.Meta`2.Metadata">
            <summary>Associated metadata object. Could be anything.</summary>
        </member>
        <member name="M:DryIoc.Meta`2.#ctor(`0,`1)">
            <summary>Boxes value and its associated metadata together.</summary>
            <param name="value">value</param> <param name="metadata">any metadata object</param>
        </member>
        <member name="T:DryIoc.ContainerException">
            <summary>Exception that container throws in case of error. Dedicated exception type simplifies
            filtering or catching container relevant exceptions from client code.</summary>
        </member>
        <member name="F:DryIoc.ContainerException.Error">
            <summary>Error code of exception, possible values are listed in <see cref="F:DryIoc.ContainerException.Error"/> class.</summary>
        </member>
        <member name="M:DryIoc.ContainerException.Of(DryIoc.ErrorCheck,System.Int32,System.Object,System.Object,System.Object,System.Object,System.Exception)">
            <summary>Creates exception by wrapping <paramref name="errorCode"/> and its message,
            optionally with <paramref name="innerException"/> exception.</summary>
            <param name="errorCheck">Type of check</param>
            <param name="errorCode">Error code, check <see cref="F:DryIoc.ContainerException.Error"/> for possible values.</param>
            <param name="arg0">(optional) Arguments for formatted message.</param> <param name="arg1"></param> <param name="arg2"></param> <param name="arg3"></param>
            <param name="innerException">(optional) Inner exception.</param>
            <returns>Created exception.</returns>
        </member>
        <member name="M:DryIoc.ContainerException.GetMessage(DryIoc.ErrorCheck,System.Int32)">
            <summary>Gets error message based on provided args.</summary> <param name="errorCheck"></param> <param name="errorCode"></param>
            <returns>message format.</returns>
        </member>
        <member name="M:DryIoc.ContainerException.Print(System.Object)">
            <summary>Prints argument for formatted message.</summary> <param name="arg">To print.</param> <returns>Printed string.</returns>
        </member>
        <member name="M:DryIoc.ContainerException.#ctor(System.Int32,System.String,System.Exception)">
            <summary>Creates exception with message describing cause and context of error,
            and leading/system exception causing it.</summary>
            <param name="error">Error code.</param> <param name="message">Error message.</param>
            <param name="innerException">Underlying system/leading exception.</param>
        </member>
        <member name="M:DryIoc.ContainerException.#ctor(System.Int32,System.String)">
            <summary>Creates exception with message describing cause and context of error.</summary>
            <param name="error">Error code.</param> <param name="message">Error message.</param>
        </member>
        <member name="T:DryIoc.Error">
            <summary>Defines error codes and error messages for all DryIoc exceptions (DryIoc extensions may define their own.)</summary>
        </member>
        <member name="F:DryIoc.Error.FirstErrorCode">
            <summary>First error code to identify error range for other possible error code definitions.</summary>
        </member>
        <member name="F:DryIoc.Error.Messages">
            <summary>List of error messages indexed with code.</summary>
        </member>
        <member name="M:DryIoc.Error.Of(System.String)">
            <summary>Stores new error message and returns error code for it.</summary>
            <param name="message">Error message to store.</param> <returns>Error code for message.</returns>
        </member>
        <member name="M:DryIoc.Error.NameOf(System.Int32)">
            <summary>Returns the name for the provided error code.</summary>
            <param name="error">error code.</param> <returns>name of error, unique in scope of this <see cref="T:DryIoc.Error"/> class.</returns>
        </member>
        <member name="T:DryIoc.ErrorCheck">
            <summary>Checked error condition, possible error sources.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.Unspecified">
            <summary>Unspecified, just throw.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.InvalidCondition">
            <summary>Predicate evaluated to false.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.IsNull">
            <summary>Checked object is null.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.IsNotOfType">
            <summary>Checked object is of unexpected type.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.TypeIsNotOfType">
            <summary>Checked type is not assignable to expected type</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.OperationThrows">
            <summary>Invoked operation throws, it is source of inner exception.</summary>
        </member>
        <member name="T:DryIoc.Throw">
            <summary>Enables more clean error message formatting and a bit of code contracts.</summary>
        </member>
        <member name="M:DryIoc.Throw.GetDefaultMessage(DryIoc.ErrorCheck)">
            <summary>Returns the default message specified for <see cref="T:DryIoc.ErrorCheck"/> code.</summary>
            <param name="error">Error code to get message for.</param> <returns>String format message.</returns>
        </member>
        <member name="T:DryIoc.Throw.GetMatchedExceptionHandler">
            <summary>Declares mapping between <see cref="T:DryIoc.ErrorCheck"/> type and <paramref name="error"/> code to specific <see cref="T:System.Exception"/>.</summary>
            <returns>Returns mapped exception.</returns>
        </member>
        <member name="F:DryIoc.Throw.GetMatchedException">
            <summary>Returns matched exception for error check and error code.</summary>
        </member>
        <member name="M:DryIoc.Throw.If(System.Boolean,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Throws matched exception if throw condition is true.</summary>
            <param name="throwCondition">Condition to be evaluated, throws if result is true, otherwise - does nothing.</param>
            <param name="error">Error code to match to exception thrown.</param>
            <param name="arg0">Arguments to formatted message.</param> <param name="arg1"></param> <param name="arg2"></param> <param name="arg3"></param>
        </member>
        <member name="M:DryIoc.Throw.ThrowIf``1(``0,System.Boolean,System.Int32,System.Object,System.Object,System.Object)">
            <summary>Throws matched exception if throw condition is true. Otherwise return source <paramref name="arg0"/>.</summary>
            <typeparam name="T">Type of source <paramref name="arg0"/>.</typeparam>
            <param name="arg0">In case of exception <paramref name="arg0"/> will be used as first argument in formatted message.</param>
            <param name="throwCondition">Condition to be evaluated, throws if result is true, otherwise - does nothing.</param>
            <param name="error">Error code to match to exception thrown.</param>
            <param name="arg1">Rest of arguments to formatted message.</param> <param name="arg2"></param> <param name="arg3"></param>
            <returns><paramref name="arg0"/> if throw condition is false.</returns>
        </member>
        <member name="M:DryIoc.Throw.ThrowIfNull``1(``0,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Throws exception if <paramref name="arg"/> is null, otherwise returns <paramref name="arg"/>.</summary>
            <param name="arg">Argument to check for null.</param>
            <param name="error">Error code.</param>
            <param name="arg0"></param> <param name="arg1"></param> <param name="arg2"></param> <param name="arg3"></param>
            <typeparam name="T">Type of argument to check and return.</typeparam>
            <returns><paramref name="arg"/> if it is not null.</returns>
        </member>
        <member name="M:DryIoc.Throw.ThrowIfNotOf``1(``0,System.Type,System.Int32,System.Object,System.Object)">
            <summary>Throws exception if <paramref name="arg0"/> is not assignable to type specified by <paramref name="arg1"/>,
            otherwise just returns <paramref name="arg0"/>.</summary>
            <typeparam name="T">Type of argument to check and return if no error.</typeparam>
            <param name="arg0">Instance to check if it is assignable to type <paramref name="arg1"/>.</param>
            <param name="arg1">Type to check <paramref name="arg0"/> against.</param>
            <param name="error">Error code</param>
            <param name="arg2"></param> <param name="arg3"></param>
            <returns><paramref name="arg0"/> if it assignable to <paramref name="arg1"/>.</returns>
        </member>
        <member name="M:DryIoc.Throw.ThrowIfNotImplementedBy(System.Type,System.Type,System.Int32,System.Object,System.Object)">
            <summary>Throws if <paramref name="arg0"/> is not assignable from <paramref name="arg1"/>.</summary>
            <param name="arg0"></param> <param name="arg1"></param>
            <param name="error">Error code</param>
             <param name="arg2"></param> <param name="arg3"></param>
            <returns><paramref name="arg0"/> if no exception.</returns>
        </member>
        <member name="M:DryIoc.Throw.IfThrows``2(System.Func{``1},System.Boolean,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Invokes <paramref name="operation"/> and in case of <typeparamref name="TEx"/> re-throws it as inner-exception.</summary>
            <typeparam name="TEx">Exception to check and handle, and then wrap as inner-exception.</typeparam>
            <typeparam name="T">Result of <paramref name="operation"/>.</typeparam>
            <param name="operation">To invoke</param>
            <param name="throwCondition">Condition to be evaluated, throws if result is true, otherwise - does nothing.</param>
            <param name="error">Error code</param>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <returns>Result of <paramref name="operation"/> if no exception.</returns>
        </member>
        <member name="M:DryIoc.Throw.It(System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Just throws the exception with the <paramref name="error"/> code.</summary>
            <param name="error">Error code.</param>
            <param name="arg0"></param> <param name="arg1"></param> <param name="arg2"></param> <param name="arg3"></param>
        </member>
        <member name="M:DryIoc.Throw.For``1(System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Throws <paramref name="error"/> instead of returning value of <typeparamref name="T"/>.
            Supposed to be used in expression that require some return value.</summary>
            <typeparam name="T"></typeparam> <param name="error"></param>
            <param name="arg0"></param> <param name="arg1"></param> <param name="arg2"></param> <param name="arg3"></param>
            <returns>Does not return, throws instead.</returns>
        </member>
        <member name="T:DryIoc.ThrowInGeneratedCode">
            <summary>Called from generated code.</summary>
        </member>
        <member name="M:DryIoc.ThrowInGeneratedCode.ThrowNewErrorIfNull(System.Object,System.String)">
            <summary>Throws if object is null.</summary>
            <param name="obj">object to check.</param><param name="message">Error message.</param>
            <returns>object if not null.</returns>
        </member>
        <member name="T:DryIoc.ReflectionTools">
            <summary>Contains helper methods to work with Type: for instance to find Type implemented base types and interfaces, etc.</summary>
        </member>
        <member name="T:DryIoc.ReflectionTools.AsImplementedType">
            <summary>Flags for <see cref="M:DryIoc.ReflectionTools.GetImplementedTypes(System.Type,DryIoc.ReflectionTools.AsImplementedType)"/> method.</summary>
        </member>
        <member name="F:DryIoc.ReflectionTools.AsImplementedType.None">
            <summary>Include nor object not source type.</summary>
        </member>
        <member name="F:DryIoc.ReflectionTools.AsImplementedType.SourceType">
            <summary>Include source type to list of implemented types.</summary>
        </member>
        <member name="F:DryIoc.ReflectionTools.AsImplementedType.ObjectType">
            <summary>Include <see cref="T:System.Object"/> type to list of implemented types.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetImplementedTypes(System.Type,DryIoc.ReflectionTools.AsImplementedType)">
            <summary>Returns all interfaces and all base types (in that order) implemented by <paramref name="sourceType"/>.
            Specify <paramref name="asImplementedType"/> to include <paramref name="sourceType"/> itself as first item and
            <see cref="T:System.Object"/> type as the last item.</summary>
            <param name="sourceType">Source type for discovery.</param>
            <param name="asImplementedType">Additional types to include into result collection.</param>
            <returns>Array of found types, empty if nothing found.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetImplementedInterfaces(System.Type)">
            <summary>Gets a collection of the interfaces implemented by the current type and its base types.</summary>
            <param name="type">Source type</param>
            <returns>Collection of interface types.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAllMembers(System.Type,System.Boolean)">
            <summary>Gets all declared and base members.</summary>
            <param name="type">Type to get members from.</param>
            <param name="includeBase">(optional) When set looks into base members.</param>
            <returns>All members.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.ContainsAllGenericTypeParameters(System.Type,System.Type[])">
            <summary>Returns true if <paramref name="openGenericType"/> contains all generic parameters
            from <paramref name="genericParameters"/>.</summary>
            <param name="openGenericType">Expected to be open-generic type, throws otherwise.</param>
            <param name="genericParameters">Generic parameters.</param>
            <returns>Returns true if contains, and false otherwise.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsCompilerGenerated(System.Type)">
            <summary>Returns true if class is compiler generated. Checking for CompilerGeneratedAttribute
            is not enough, because this attribute is not applied for classes generated from "async/await".</summary>
            <param name="type">Type to check.</param> <returns>Returns true if type is compiler generated.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsGeneric(System.Type)">
            <summary>Returns true if type is generic.</summary><param name="type">Type to check.</param> <returns>True if type generic.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsGenericDefinition(System.Type)">
            <summary>Returns true if type is generic type definition (open type).</summary><param name="type">Type to check.</param>
            <returns>True if type is open type: generic type definition.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsClosedGeneric(System.Type)">
            <summary>Returns true if type is closed generic: does not have open generic parameters, only closed/concrete ones.</summary>
            <param name="type">Type to check</param> <returns>True if closed generic.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsOpenGeneric(System.Type)">
            <summary>Returns true if type if open generic: contains at list one open generic parameter. Could be
            generic type definition as well.</summary>
            <param name="type">Type to check.</param> <returns>True if open generic.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetGenericDefinitionOrNull(System.Type)">
            <summary>Returns generic type definition if type is generic and null otherwise.</summary>
            <param name="type">Source type, could be null.</param> <returns>Generic type definition.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetGenericParamsAndArgs(System.Type)">
            <summary>Returns generic type parameters and arguments in order they specified. If type is not generic, returns empty array.</summary>
            <param name="type">Source type.</param> <returns>Array of generic type arguments (closed/concrete types) and parameters (open).</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetGenericParamConstraints(System.Type)">
            <summary>Returns array of interface and base class constraints for provider generic parameter type.</summary>
            <param name="type">Generic parameter type.</param>
            <returns>Array of interface and base class constraints.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetArrayElementTypeOrNull(System.Type)">
            <summary>If type is array returns is element type, otherwise returns null.</summary>
            <param name="type">Source type.</param> <returns>Array element type or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetBaseType(System.Type)">
            <summary>Return base type or null, if not exist (the case for only for object type).</summary>
            <param name="type">Source type.</param> <returns>Base type or null for object.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsPublicOrNestedPublic(System.Type)">
            <summary>Checks if type is public or nested public in public type.</summary>
            <param name="type">Type to check.</param> <returns>Return true if check succeeded.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsClass(System.Type)">
            <summary>Returns true if type is class.</summary>
            <param name="type">Type to check.</param> <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsValueType(System.Type)">
            <summary>Returns true if type is value type.</summary>
            <param name="type">Type to check.</param> <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsInterface(System.Type)">
            <summary>Returns true if type is interface.</summary>
            <param name="type">Type to check.</param> <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsAbstract(System.Type)">
            <summary>Returns true if type if abstract or interface.</summary>
            <param name="type">Type to check.</param> <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsStatic(System.Type)">
            <summary>Returns true if type is static.</summary>
            <param name="type">Type</param> <returns>True is static.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsEnum(System.Type)">
            <summary>Returns true if type is enum type.</summary>
            <param name="type">Type to check.</param> <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsAssignableTo(System.Type,System.Type)">
            <summary>Returns true if instance of type is assignable to instance of <paramref name="other"/> type.</summary>
            <param name="type">Type to check, could be null.</param>
            <param name="other">Other type to check, could be null.</param>
            <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsTypeOf(System.Type,System.Object)">
            <summary>Returns true if type of <paramref name="obj"/> is assignable to source <paramref name="type"/>.</summary>
            <param name="type">Is type of object.</param> <param name="obj">Object to check.</param>
            <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsPrimitive(System.Type,System.Boolean)">
            <summary>Returns true if provided type IsPitmitive in .Net terms, or enum, or string
            , or array of primitives if <paramref name="orArrayOfPrimitives"/> is true.</summary>
            <param name="type">Type to check.</param>
            <param name="orArrayOfPrimitives">Says to return true for array or primitives recursively.</param>
            <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAttributes(System.Type,System.Type,System.Boolean)">
            <summary>Returns all attributes defined on <paramref name="type"/>.</summary>
            <param name="type">Type to get attributes for.</param>
            <param name="attributeType">(optional) Check only for that attribute type, otherwise for any attribute.</param>
            <param name="inherit">(optional) Additionally check for attributes inherited from base type.</param>
            <returns>Sequence of found attributes or empty.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetMembers``1(System.Type,System.Func{System.Reflection.TypeInfo,System.Collections.Generic.IEnumerable{``0}},System.Boolean)">
            <summary>Recursive method to enumerate all input type and its base types for specific details.
            Details are returned by <paramref name="getMembers"/> delegate.</summary>
            <typeparam name="TMember">Details type: properties, fields, methods, etc.</typeparam>
            <param name="type">Input type.</param> <param name="getMembers">Get declared type details.</param>
            <param name="includeBase">(optional) When set looks into base members.</param>
            <returns>Enumerated details info objects.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetDeclaredAndBase``1(System.Type,System.Func{System.Reflection.TypeInfo,System.Collections.Generic.IEnumerable{``0}})">
            <summary>Obsolete: replaced with <see cref="M:DryIoc.ReflectionTools.GetMembers``1(System.Type,System.Func{System.Reflection.TypeInfo,System.Collections.Generic.IEnumerable{``0}},System.Boolean)"/>.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetPublicInstanceConstructors(System.Type)">
            <summary>Returns all public instance constructors for the type</summary>
            <param name="type"></param> <returns></returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAllConstructors(System.Type,System.Boolean,System.Boolean)">
            <summary>Enumerates all constructors from input type.</summary>
            <param name="type">Input type.</param>
            <param name="includeNonPublic">(optional) If set include non-public constructors into result.</param>
            <param name="includeStatic">(optional) Turned off by default.</param>
            <returns>Enumerated constructors.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetConstructorOrNull(System.Type,System.Boolean,System.Type[])">
            <summary>Searches and returns constructor by its signature.</summary>
            <param name="type">Input type.</param>
            <param name="includeNonPublic">(optional) If set include non-public constructors into result.</param>
            <param name="args">Signature - constructor argument types.</param>
            <returns>Found constructor or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetSingleConstructorOrNull(System.Type,System.Boolean)">
            <summary>Returns single constructor, otherwise if no or more than one: returns false.</summary>
            <param name="type">Type to inspect.</param>
            <param name="includeNonPublic">(optional) If set includes non-public constructors.</param>
            <returns>Single constructor or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetSingleMethodOrNull(System.Type,System.String,System.Boolean)">
            <summary>Returns single declared (not inherited) method by name, or null if not found.</summary>
            <param name="type">Input type</param> <param name="name">Method name to look for.</param>
            <param name="includeNonPublic">(optional) If set includes non public methods into search.</param>
            <returns>Found method or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetMethodOrNull(System.Type,System.String,System.Type[])">
            <summary>Returns declared (not inherited) method by name and argument types, or null if not found.</summary>
            <param name="type">Input type</param> <param name="name">Method name to look for.</param>
            <param name="paramTypes">Argument types</param> <returns>Found method or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetPropertyOrNull(System.Type,System.String)">
            <summary>Returns property by name, including inherited. Or null if not found.</summary>
            <param name="type">Input type.</param> <param name="name">Property name to look for.</param>
            <returns>Found property or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetFieldOrNull(System.Type,System.String)">
            <summary>Returns field by name, including inherited. Or null if not found.</summary>
            <param name="type">Input type.</param> <param name="name">Field name to look for.</param>
            <returns>Found field or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAssembly(System.Type)">
            <summary>Returns type assembly.</summary> <param name="type">Input type</param> <returns>Type assembly.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsExplicitlyImplemented(System.Reflection.PropertyInfo)">
            <summary>Is <c>true</c> for interface declared property explicitly implemented, e.g. <c>IInterface.Prop</c></summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsStatic(System.Reflection.MemberInfo)">
            <summary>Returns true if member is static, otherwise returns false.</summary>
            <param name="member">Member to check.</param> <returns>True if static.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetReturnTypeOrDefault(System.Reflection.MemberInfo)">
            <summary>Return either <see cref="P:System.Reflection.PropertyInfo.PropertyType"/>, or <see cref="P:System.Reflection.FieldInfo.FieldType"/>, <see cref="P:System.Reflection.MethodInfo.ReturnType"/>.
            Otherwise returns null.</summary>
            <param name="member">Expecting member of type <see cref="T:System.Reflection.PropertyInfo"/> or <see cref="T:System.Reflection.FieldInfo"/> only.</param>
            <returns>Type of property of field.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsBackingField(System.Reflection.FieldInfo)">
            <summary>Returns true if field is backing field for property.</summary>
            <param name="field">Field to check.</param> <returns>Returns true if field is backing property.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsIndexer(System.Reflection.PropertyInfo)">
            <summary>Returns true if property is indexer: aka this[].</summary>
            <param name="property">Property to check</param><returns>True if indexer.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsClosureType(System.Type)">
            <summary>Returns true if type is generated type of hoisted closure.</summary>
            <param name="type">Source type.</param> <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAttributes(System.Reflection.MemberInfo,System.Type,System.Boolean)">
            <summary>Returns attributes defined for the member/method.</summary>
            <param name="member">Member to check.</param> <param name="attributeType">(optional) Specific attribute type to return, any attribute otherwise.</param>
            <param name="inherit">Check for inherited member attributes.</param> <returns>Found attributes or empty.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAttributes(System.Reflection.ParameterInfo,System.Type,System.Boolean)">
            <summary>Returns attributes defined for parameter.</summary>
             <param name="parameter">Target parameter.</param>
            <param name="attributeType">(optional) Specific attribute type to return, any attribute otherwise.</param>
            <param name="inherit">Check for inherited attributes.</param> <returns>Found attributes or empty.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetLoadedTypes(System.Reflection.Assembly)">
            <summary>Get types from assembly that are loaded successfully.
            Hacks to <see cref="T:System.Reflection.ReflectionTypeLoadException"/> for loaded types.</summary>
            <param name="assembly">Assembly to get types from.</param>
            <returns>Array of loaded types.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetDefaultValueExpression(System.Type)">
            <summary>Creates default(T) expression for provided <paramref name="type"/>.</summary>
            <param name="type">Type to get default value of.</param>
            <returns>Default value expression.</returns>
        </member>
        <member name="T:DryIoc.PrintTools">
            <summary>Provides pretty printing/debug view for number of types.</summary>
        </member>
        <member name="F:DryIoc.PrintTools.DefaultItemSeparator">
            <summary>Default separator used for printing enumerable.</summary>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.Object,System.String,System.String,System.Func{System.Type,System.String})">
            <summary>Prints input object by using corresponding Print methods for know types.</summary>
            <param name="s">Builder to append output to.</param>
            <param name="x">Object to print.</param>
            <param name="quote">(optional) Quote to use for quoting string object.</param>
            <param name="itemSeparator">(optional) Separator for enumerable.</param>
            <param name="getTypeName">(optional) Custom type printing policy.</param>
            <returns>String builder with appended output.</returns>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.String,System.String)">
            <summary>Appends string to string builder quoting with <paramref name="quote"/> if provided.</summary>
            <param name="s">String builder to append string to.</param>
            <param name="str">String to print.</param>
            <param name="quote">(optional) Quote to add before and after string.</param>
            <returns>String builder with appended string.</returns>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.Collections.IEnumerable,System.String,System.Action{System.Text.StringBuilder,System.Object})">
            <summary>Prints enumerable by using corresponding Print method for known item type.</summary>
            <param name="s">String builder to append output to.</param>
            <param name="items">Items to print.</param>
            <param name="separator">(optional) Custom separator if provided.</param>
            <param name="printItem">(optional) Custom item printer if provided.</param>
            <returns>String builder with appended output.</returns>
        </member>
        <member name="F:DryIoc.PrintTools.GetTypeNameDefault">
            <summary>Default delegate to print Type details: by default prints Type FullName and
            skips namespace if it start with "System."</summary>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.Type,System.Func{System.Type,System.String})">
            <summary>Appends type details to string builder.</summary>
            <param name="s">String builder to append output to.</param>
            <param name="type">Input type to print.</param>
            <param name="getTypeName">(optional) Delegate to provide custom type details.</param>
            <returns>String builder with appended output.</returns>
        </member>
        <member name="T:DryIoc.Portable">
            <summary>Ports some methods from .Net 4.0/4.5</summary>
        </member>
        <member name="F:DryIoc.Portable.GetAssemblyTypes">
            <summary>Portable version of Assembly.GetTypes or Assembly.DefinedTypes.</summary>
        </member>
        <member name="M:DryIoc.Portable.GetGetMethodOrNull(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>Portable version of PropertyInfo.GetGetMethod.</summary>
            <param name="p">Target property info</param>
            <param name="includeNonPublic">(optional) If set then consider non-public getter</param>
            <returns>Setter method info if it is defined for property.</returns>
        </member>
        <member name="M:DryIoc.Portable.GetSetMethodOrNull(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>Portable version of PropertyInfo.GetSetMethod.</summary>
            <param name="p">Target property info</param>
            <param name="includeNonPublic">(optional) If set then consider non-public setter</param>
            <returns>Setter method info if it is defined for property.</returns>
        </member>
        <member name="M:DryIoc.Portable.GetCurrentManagedThreadID">
            <summary>Returns managed Thread ID either from Environment or Thread.CurrentThread whichever is available.</summary>
            <returns>Managed Thread ID.</returns>
        </member>
        <member name="T:DryIoc.Experimental.DI">
            <summary>Succinct convention-based, LINQ like API to resolve resolution root at the end.</summary>
        </member>
        <member name="F:DryIoc.Experimental.DI.Relaxed">
            <summary>Pre-configured auto-magic rules.</summary>
        </member>
        <member name="M:DryIoc.Experimental.DI.New(System.Func{DryIoc.Rules,DryIoc.Rules})">
            <summary>Creates new default configured container</summary>
            <param name="configure">(optional) Additional rules.</param>
            <returns>New configured container.</returns>
        </member>
        <member name="M:DryIoc.Experimental.DI.Get``1(System.Reflection.Assembly[])">
            <summary>Auto-wired resolution of T from the container.</summary>
            <typeparam name="T">Type of service to resolve.</typeparam>
            <param name="assemblies">(optional) Assemblies to look for services implementations.</param>
            <returns>Resolved service or throws.</returns>
        </member>
        <member name="M:DryIoc.Experimental.DI.Get``1(DryIoc.IContainer,System.Reflection.Assembly[])">
            <summary>Auto-wired resolution of T from the container.</summary>
            <typeparam name="T">Type of service to resolve.</typeparam>
            <param name="container">(optional) Container to resolve from.</param>
            <param name="assemblies">(optional) Assemblies to look for service implementation and dependencies.</param>
            <returns>Resolved service or throws.</returns>
        </member>
        <member name="T:DryIoc.AsyncExecutionFlowScopeContext">
            <summary>Stores scopes propagating through async-await boundaries.</summary>
        </member>
        <member name="F:DryIoc.AsyncExecutionFlowScopeContext.ScopeContextName">
            <summary>Statically known name of root scope in this context.</summary>
        </member>
        <member name="P:DryIoc.AsyncExecutionFlowScopeContext.RootScopeName">
            <summary>Name associated with context root scope - so the reuse may find scope context.</summary>
        </member>
        <member name="M:DryIoc.AsyncExecutionFlowScopeContext.GetCurrentOrDefault">
            <summary>Returns current scope or null if no ambient scope available at the moment.</summary>
            <returns>Current scope or null.</returns>
        </member>
        <member name="M:DryIoc.AsyncExecutionFlowScopeContext.SetCurrent(DryIoc.SetCurrentScopeHandler)">
            <summary>Changes current scope using provided delegate. Delegate receives current scope as input and  should return new current scope.</summary>
            <param name="changeCurrentScope">Delegate to change the scope.</param>
            <remarks>Important: <paramref name="changeCurrentScope"/> may be called multiple times in concurrent environment.
            Make it predictable by removing any side effects.</remarks>
            <returns>New current scope. It is convenient to use method in "using (var newScope = ctx.SetCurrent(...))".</returns>
        </member>
        <member name="M:DryIoc.AsyncExecutionFlowScopeContext.Dispose">
            <summary>Nothing to dispose.</summary>
        </member>
        <member name="T:ImTools.ArrayTools">
            <summary>Methods to work with immutable arrays, and general array sugar.</summary>
        </member>
        <member name="M:ImTools.ArrayTools.IsNullOrEmpty``1(``0[])">
            <summary>Returns true if array is null or have no items.</summary> <typeparam name="T">Type of array item.</typeparam>
            <param name="source">Source array to check.</param> <returns>True if null or has no items, false otherwise.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.EmptyIfNull``1(``0[])">
            <summary>Returns empty array instead of null, or source array otherwise.</summary> <typeparam name="T">Type of array item.</typeparam>
            <param name="source">Source array.</param> <returns>Empty array or source.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.ToArrayOrSelf``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns source enumerable if it is array, otherwise converts source to array.</summary>
            <typeparam name="T">Array item type.</typeparam>
            <param name="source">Source enumerable.</param>
            <returns>Source enumerable or its array copy.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Append``1(``0[],``0[])">
            <summary>Returns new array consisting from all items from source array then all items from added array.
            If source is null or empty, then added array will be returned.
            If added is null or empty, then source will be returned.</summary>
            <typeparam name="T">Array item type.</typeparam>
            <param name="source">Array with leading items.</param>
            <param name="added">Array with following items.</param>
            <returns>New array with items of source and added arrays.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Append``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Performant concat of enumerables in case they are arrays. 
            But performance will degrade if you use Concat().Where().</summary>
            <typeparam name="T">Type of item.</typeparam>
            <param name="source">goes first.</param>
            <param name="other">appended to source.</param>
            <returns>empty array or concat of source and other.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.AppendOrUpdate``1(``0[],``0,System.Int32)">
            <summary>Returns new array with <paramref name="value"/> appended, 
            or <paramref name="value"/> at <paramref name="index"/>, if specified.
            If source array could be null or empty, then single value item array will be created despite any index.</summary>
            <typeparam name="T">Array item type.</typeparam>
            <param name="source">Array to append value to.</param>
            <param name="value">Value to append.</param>
            <param name="index">(optional) Index of value to update.</param>
            <returns>New array with appended or updated value.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.IndexOf``1(``0[],System.Func{``0,System.Boolean})">
            <summary>Calls predicate on each item in <paramref name="source"/> array until predicate returns true,
            then method will return this item index, or if predicate returns false for each item, method will return -1.</summary>
            <typeparam name="T">Type of array items.</typeparam>
            <param name="source">Source array: if null or empty, then method will return -1.</param>
            <param name="predicate">Delegate to evaluate on each array item until delegate returns true.</param>
            <returns>Index of item for which predicate returns true, or -1 otherwise.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.IndexOf``1(``0[],``0)">
            <summary>Looks up for item in source array equal to provided value, and returns its index, or -1 if not found.</summary>
            <typeparam name="T">Type of array items.</typeparam>
            <param name="source">Source array: if null or empty, then method will return -1.</param>
            <param name="value">Value to look up.</param>
            <returns>Index of item equal to value, or -1 item is not found.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.FindFirst``1(``0[],System.Func{``0,System.Boolean})">
            <summary>Returns first item matching the <paramref name="predicate"/>, or default item value.</summary>
            <typeparam name="T">item type</typeparam>
            <param name="source">items collection to search</param>
            <param name="predicate">condition to evaluate for each item.</param>
            <returns>First item matching condition or default value.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.FindFirst``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Returns first item matching the <paramref name="predicate"/>, or default item value.</summary>
            <typeparam name="T">item type</typeparam>
            <param name="source">items collection to search</param>
            <param name="predicate">condition to evaluate for each item.</param>
            <returns>First item matching condition or default value.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Match``1(``0[],System.Func{``0,System.Boolean})">
            <summary>Where method similar to Enumerable.Where but more performant and non necessary allocating.
            It returns source array and does Not create new one if all items match the condition.</summary>
            <typeparam name="T">Type of source items.</typeparam>
            <param name="source">If null, the null will be returned.</param>
            <param name="condition">Condition to keep items.</param>
            <returns>New array if some items are filter out. Empty array if all items are filtered out. Original array otherwise.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Match``2(``0[],System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>Where method similar to Enumerable.Where but more performant and non necessary allocating.
            It returns source array and does Not create new one if all items match the condition.</summary>
            <typeparam name="T">Type of source items.</typeparam> <typeparam name="R">Type of result items.</typeparam>
            <param name="source">If null, the null will be returned.</param>
            <param name="condition">Condition to keep items.</param> <param name="map">Converter from source to result item.</param>
            <returns>New array of result items.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Map``2(``0[],System.Func{``0,``1})">
            <summary>Maps all items from source to result array.</summary>
            <typeparam name="T">Source item type</typeparam> <typeparam name="R">Result item type</typeparam>
            <param name="source">Source items</param> <param name="map">Function to convert item from source to result.</param>
            <returns>Converted items</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Map``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Maps all items from source to result collection. 
            If possible uses fast array Map otherwise Enumerable.Select.</summary>
            <typeparam name="T">Source item type</typeparam> <typeparam name="R">Result item type</typeparam>
            <param name="source">Source items</param> <param name="map">Function to convert item from source to result.</param>
            <returns>Converted items</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Match``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>If <paramref name="source"/> is array uses more effective Match for array, otherwise just calls Where</summary>
            <typeparam name="T">Type of source items.</typeparam>
            <param name="source">If null, the null will be returned.</param>
            <param name="condition">Condition to keep items.</param>
            <returns>Result items, may be an array.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Match``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>If <paramref name="source"/> is array uses more effective Match for array,
            otherwise just calls Where, Select</summary>
            <typeparam name="T">Type of source items.</typeparam> <typeparam name="R">Type of result items.</typeparam>
            <param name="source">If null, the null will be returned.</param>
            <param name="condition">Condition to keep items.</param>  <param name="map">Converter from source to result item.</param>
            <returns>Result items, may be an array.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.RemoveAt``1(``0[],System.Int32)">
            <summary>Produces new array without item at specified <paramref name="index"/>. 
            Will return <paramref name="source"/> array if index is out of bounds, or source is null/empty.</summary>
            <typeparam name="T">Type of array item.</typeparam>
            <param name="source">Input array.</param> <param name="index">Index if item to remove.</param>
            <returns>New array with removed item at index, or input source array if index is not in array.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Remove``1(``0[],``0)">
            <summary>Looks for item in array using equality comparison, and returns new array with found item remove, or original array if not item found.</summary>
            <typeparam name="T">Type of array item.</typeparam>
            <param name="source">Input array.</param> <param name="value">Value to find and remove.</param>
            <returns>New array with value removed or original array if value is not found.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Empty``1">
            <summary>Returns singleton empty array of provided type.</summary> 
            <typeparam name="T">Array item type.</typeparam> <returns>Empty array.</returns>
        </member>
        <member name="T:ImTools.Ref`1">
            <summary>Wrapper that provides optimistic-concurrency Swap operation implemented using <see cref="M:ImTools.Ref.Swap``1(``0@,System.Func{``0,``0})"/>.</summary>
            <typeparam name="T">Type of object to wrap.</typeparam>
        </member>
        <member name="P:ImTools.Ref`1.Value">
            <summary>Gets the wrapped value.</summary>
        </member>
        <member name="M:ImTools.Ref`1.#ctor(`0)">
            <summary>Creates ref to object, optionally with initial value provided.</summary>
            <param name="initialValue">(optional) Initial value.</param>
        </member>
        <member name="M:ImTools.Ref`1.Swap(System.Func{`0,`0})">
            <summary>Exchanges currently hold object with <paramref name="getNewValue"/> - see <see cref="M:ImTools.Ref.Swap``1(``0@,System.Func{``0,``0})"/> for details.</summary>
            <param name="getNewValue">Delegate to produce new object value from current one passed as parameter.</param>
            <returns>Returns old object value the same way as <see cref="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)"/></returns>
            <remarks>Important: <paramref name="getNewValue"/> May be called multiple times to retry update with value concurrently changed by other code.</remarks>
        </member>
        <member name="M:ImTools.Ref`1.Swap(`0)">
            <summary>Just sets new value ignoring any intermingled changes.</summary>
            <param name="newValue"></param> <returns>old value</returns>
        </member>
        <member name="M:ImTools.Ref`1.TrySwapIfStillCurrent(`0,`0)">
            <summary>Compares current Referred value with <paramref name="currentValue"/> and if equal replaces current with <paramref name="newValue"/></summary>
            <param name="currentValue"></param> <param name="newValue"></param>
            <returns>True if current value was replaced with new value, and false if current value is outdated (already changed by other party).</returns>
            <example><c>[!CDATA[
            var value = SomeRef.Value;
            if (!SomeRef.TrySwapIfStillCurrent(value, Update(value))
                SomeRef.Swap(v => Update(v)); // fallback to normal Swap with delegate allocation
            ]]</c></example>
        </member>
        <member name="T:ImTools.Ref">
            <summary>Provides optimistic-concurrency consistent <see cref="M:ImTools.Ref.Swap``1(``0@,System.Func{``0,``0})"/> operation.</summary>
        </member>
        <member name="M:ImTools.Ref.Of``1(``0)">
            <summary>Factory for <see cref="T:ImTools.Ref`1"/> with type of value inference.</summary>
            <typeparam name="T">Type of value to wrap.</typeparam>
            <param name="value">Initial value to wrap.</param>
            <returns>New ref.</returns>
        </member>
        <member name="M:ImTools.Ref.NewRef``1(ImTools.Ref{``0})">
            <summary>Creates new ref to the value of original ref.</summary> <typeparam name="T">Ref value type.</typeparam>
            <param name="original">Original ref.</param> <returns>New ref to original value.</returns>
        </member>
        <member name="M:ImTools.Ref.Swap``1(``0@,System.Func{``0,``0})">
            <summary>First, it evaluates new value using <paramref name="getNewValue"/> function. 
            Second, it checks that original value is not changed. 
            If it is changed it will retry first step, otherwise it assigns new value and returns original (the one used for <paramref name="getNewValue"/>).</summary>
            <typeparam name="T">Type of value to swap.</typeparam>
            <param name="value">Reference to change to new value</param>
            <param name="getNewValue">Delegate to get value from old one.</param>
            <returns>Old/original value. By analogy with <see cref="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)"/>.</returns>
            <remarks>Important: <paramref name="getNewValue"/> May be called multiple times to retry update with value concurrently changed by other code.</remarks>
        </member>
        <member name="T:ImTools.KV`2">
            <summary>Immutable Key-Value pair. It is reference type (could be check for null), 
            which is different from System value type <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            In addition provides <see cref="M:ImTools.KV`2.Equals(System.Object)"/> and <see cref="M:ImTools.KV`2.GetHashCode"/> implementations.</summary>
            <typeparam name="K">Type of Key.</typeparam><typeparam name="V">Type of Value.</typeparam>
        </member>
        <member name="F:ImTools.KV`2.Key">
            <summary>Key.</summary>
        </member>
        <member name="F:ImTools.KV`2.Value">
            <summary>Value.</summary>
        </member>
        <member name="M:ImTools.KV`2.#ctor(`0,`1)">
            <summary>Creates Key-Value object by providing key and value. Does Not check either one for null.</summary>
            <param name="key">key.</param><param name="value">value.</param>
        </member>
        <member name="M:ImTools.KV`2.ToString">
            <summary>Creates nice string view.</summary><returns>String representation.</returns>
        </member>
        <member name="M:ImTools.KV`2.Equals(System.Object)">
            <summary>Returns true if both key and value are equal to corresponding key-value of other object.</summary>
            <param name="obj">Object to check equality with.</param> <returns>True if equal.</returns>
        </member>
        <member name="M:ImTools.KV`2.GetHashCode">
            <summary>Combines key and value hash code. R# generated default implementation.</summary>
            <returns>Combined hash code for key-value.</returns>
        </member>
        <member name="T:ImTools.KV">
            <summary>Helpers for <see cref="T:ImTools.KV`2"/>.</summary>
        </member>
        <member name="M:ImTools.KV.Of``2(``0,``1)">
            <summary>Creates the key value pair.</summary>
            <typeparam name="K">Key type</typeparam> <typeparam name="V">Value type</typeparam>
            <param name="key">Key</param> <param name="value">Value</param> <returns>New pair.</returns>
        </member>
        <member name="M:ImTools.KV.WithKey``2(ImTools.KV{``0,``1},``0)">
            <summary>Creates the new pair with new key and old value.</summary>
            <typeparam name="K">Key type</typeparam> <typeparam name="V">Value type</typeparam>
            <param name="source">Source value</param> <param name="key">New key</param> <returns>New pair</returns>
        </member>
        <member name="M:ImTools.KV.WithValue``2(ImTools.KV{``0,``1},``1)">
            <summary>Creates the new pair with old key and new value.</summary>
            <typeparam name="K">Key type</typeparam> <typeparam name="V">Value type</typeparam>
            <param name="source">Source value</param> <param name="value">New value.</param> <returns>New pair</returns>
        </member>
        <member name="T:ImTools.Update`1">
            <summary>Delegate for changing value from old one to some new based on provided new value.</summary>
            <typeparam name="V">Type of values.</typeparam>
            <param name="oldValue">Existing value.</param>
            <param name="newValue">New value passed to Update.. method.</param>
            <returns>Changed value.</returns>
        </member>
        <member name="T:ImTools.ImTreeMapIntToObj">
            <summary>Simple immutable AVL tree with integer keys and object values.</summary>
        </member>
        <member name="F:ImTools.ImTreeMapIntToObj.Empty">
            <summary>Empty tree to start with.</summary>
        </member>
        <member name="F:ImTools.ImTreeMapIntToObj.Key">
            <summary>Key.</summary>
        </member>
        <member name="F:ImTools.ImTreeMapIntToObj.Value">
            <summary>Value.</summary>
        </member>
        <member name="F:ImTools.ImTreeMapIntToObj.Left">
            <summary>Left sub-tree/branch, or empty.</summary>
        </member>
        <member name="F:ImTools.ImTreeMapIntToObj.Right">
            <summary>Right sub-tree/branch, or empty.</summary>
        </member>
        <member name="F:ImTools.ImTreeMapIntToObj.Height">
            <summary>Height of longest sub-tree/branch plus 1. It is 0 for empty tree, and 1 for single node tree.</summary>
        </member>
        <member name="P:ImTools.ImTreeMapIntToObj.IsEmpty">
            <summary>Returns true is tree is empty.</summary>
        </member>
        <member name="M:ImTools.ImTreeMapIntToObj.AddOrUpdate(System.Int32,System.Object)">
            <summary>Returns new tree with added or updated value for specified key.</summary>
            <param name="key"></param> <param name="value"></param>
            <returns>New tree.</returns>
        </member>
        <member name="T:ImTools.ImTreeMapIntToObj.UpdateValue">
            <summary>Delegate to calculate new value from and old and a new value.</summary>
            <param name="oldValue">Old</param> <param name="newValue">New</param> <returns>Calculated result.</returns>
        </member>
        <member name="M:ImTools.ImTreeMapIntToObj.AddOrUpdate(System.Int32,System.Object,ImTools.ImTreeMapIntToObj.UpdateValue)">
            <summary>Returns new tree with added or updated value for specified key.</summary>
            <param name="key">Key</param> <param name="value">Value</param>
            <param name="updateValue">(optional) Delegate to calculate new value from and old and a new value.</param>
            <returns>New tree.</returns>
        </member>
        <member name="M:ImTools.ImTreeMapIntToObj.Update(System.Int32,System.Object)">
            <summary>Returns new tree with updated value for the key, Or the same tree if key was not found.</summary>
            <param name="key"></param> <param name="value"></param>
            <returns>New tree if key is found, or the same tree otherwise.</returns>
        </member>
        <member name="M:ImTools.ImTreeMapIntToObj.GetValueOrDefault(System.Int32)">
            <summary>Get value for found key or null otherwise.</summary>
            <param name="key"></param> <returns>Found value or null.</returns>
        </member>
        <member name="M:ImTools.ImTreeMapIntToObj.Enumerate">
            <summary>Returns all sub-trees enumerated from left to right.</summary> 
            <returns>Enumerated sub-trees or empty if tree is empty.</returns>
        </member>
        <member name="T:ImTools.ImTreeMap`2">
            <summary>Immutable http://en.wikipedia.org/wiki/AVL_tree where actual node key is hash code of <typeparamref name="K"/>.</summary>
        </member>
        <member name="F:ImTools.ImTreeMap`2.Empty">
            <summary>Empty tree to start with.</summary>
        </member>
        <member name="F:ImTools.ImTreeMap`2.Key">
            <summary>Key of type K that should support <see cref="M:System.Object.Equals(System.Object)"/> and <see cref="M:System.Object.GetHashCode"/>.</summary>
        </member>
        <member name="F:ImTools.ImTreeMap`2.Value">
            <summary>Value of any type V.</summary>
        </member>
        <member name="F:ImTools.ImTreeMap`2.Hash">
            <summary>Calculated key hash.</summary>
        </member>
        <member name="F:ImTools.ImTreeMap`2.Conflicts">
            <summary>In case of <see cref="F:ImTools.ImTreeMap`2.Hash"/> conflicts for different keys contains conflicted keys with their values.</summary>
        </member>
        <member name="F:ImTools.ImTreeMap`2.Left">
            <summary>Left sub-tree/branch, or empty.</summary>
        </member>
        <member name="F:ImTools.ImTreeMap`2.Right">
            <summary>Right sub-tree/branch, or empty.</summary>
        </member>
        <member name="F:ImTools.ImTreeMap`2.Height">
            <summary>Height of longest sub-tree/branch plus 1. It is 0 for empty tree, and 1 for single node tree.</summary>
        </member>
        <member name="P:ImTools.ImTreeMap`2.IsEmpty">
            <summary>Returns true if tree is empty.</summary>
        </member>
        <member name="M:ImTools.ImTreeMap`2.AddOrUpdate(`0,`1,ImTools.Update{`1})">
            <summary>Returns new tree with added key-value. If value with the same key is exist, then
            if <paramref name="update"/> is not specified: then existing value will be replaced by <paramref name="value"/>;
            if <paramref name="update"/> is specified: then update delegate will decide what value to keep.</summary>
            <param name="key">Key to add.</param><param name="value">Value to add.</param>
            <param name="update">(optional) Delegate to decide what value to keep: old or new one.</param>
            <returns>New tree with added or updated key-value.</returns>
        </member>
        <member name="M:ImTools.ImTreeMap`2.Update(`0,`1,ImTools.Update{`1})">
            <summary>Looks for <paramref name="key"/> and replaces its value with new <paramref name="value"/>, or 
            runs custom update handler (<paramref name="update"/>) with old and new value to get the updated result.</summary>
            <param name="key">Key to look for.</param>
            <param name="value">New value to replace key value with.</param>
            <param name="update">(optional) Delegate for custom update logic, it gets old and new <paramref name="value"/>
            as inputs and should return updated value as output.</param>
            <returns>New tree with updated value or the SAME tree if no key found.</returns>
        </member>
        <member name="M:ImTools.ImTreeMap`2.GetValueOrDefault(`0,`1)">
            <summary>Looks for key in a tree and returns the key value if found, or <paramref name="defaultValue"/> otherwise.</summary>
            <param name="key">Key to look for.</param> <param name="defaultValue">(optional) Value to return if key is not found.</param>
            <returns>Found value or <paramref name="defaultValue"/>.</returns>
        </member>
        <member name="M:ImTools.ImTreeMap`2.Enumerate">
            <summary>Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
            The only difference is using fixed size array instead of stack for speed-up (~20% faster than stack).</summary>
            <returns>Sequence of enumerated key value pairs.</returns>
        </member>
        <member name="T:ImTools.ImMap`2">
            <summary>AVL trees forest - uses last hash bits to quickly find target tree, more performant Lookup but no traversal.</summary>
            <typeparam name="K">Key type</typeparam> <typeparam name="V">Value type.</typeparam>
        </member>
        <member name="F:ImTools.ImMap`2.Empty">
            <summary>Empty tree to start with.</summary>
        </member>
        <member name="F:ImTools.ImMap`2.Count">
            <summary>Count in items stored.</summary>
        </member>
        <member name="P:ImTools.ImMap`2.IsEmpty">
            <summary>True if contains no items</summary>
        </member>
        <member name="M:ImTools.ImMap`2.GetValueOrDefault(`0,`1)">
            <summary>Looks for key in a tree and returns the key value if found, or <paramref name="defaultValue"/> otherwise.</summary>
            <param name="key">Key to look for.</param> <param name="defaultValue">(optional) Value to return if key is not found.</param>
            <returns>Found value or <paramref name="defaultValue"/>.</returns>
        </member>
        <member name="M:ImTools.ImMap`2.AddOrUpdate(`0,`1)">
            <summary>Returns new tree with added key-value. 
            If value with the same key is exist then the value is replaced.</summary>
            <param name="key">Key to add.</param><param name="value">Value to add.</param>
            <returns>New tree with added or updated key-value.</returns>
        </member>
        <member name="M:ImTools.ImMap`2.Update(`0,`1)">
            <summary>Looks for <paramref name="key"/> and replaces its value with new <paramref name="value"/></summary>
            <param name="key">Key to look for.</param>
            <param name="value">New value to replace key value with.</param>
            <returns>New tree with updated value or the SAME tree if no key found.</returns>
        </member>
        <member name="T:FastExpressionCompiler.ExpressionCompiler">
            <summary>Compiles expression to delegate ~20 times faster than Expression.Compile.
            Partial to extend with your things when used as source file.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.Compile``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>Obsolete: replaced by CompileFast extension method</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.Compile``1(System.Linq.Expressions.LambdaExpression)">
            <summary>Obsolete: replaced by CompileFast extension method</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``1(System.Linq.Expressions.LambdaExpression,System.Boolean)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast(System.Linq.Expressions.LambdaExpression,System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``2(System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Boolean)">
            <summary>Compiles lambda expression to delegatee. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}},System.Boolean)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``4(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3}},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``5(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4}},System.Boolean)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``6(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4,``5}},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``7(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4,``5,``6}},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast(System.Linq.Expressions.Expression{System.Action},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``1(System.Linq.Expressions.Expression{System.Action{``0}},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``2(System.Linq.Expressions.Expression{System.Action{``0,``1}},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``3(System.Linq.Expressions.Expression{System.Action{``0,``1,``2}},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``4(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3}},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``5(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3,``4}},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``6(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3,``4,``5}},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCompile``1(System.Linq.Expressions.LambdaExpression)">
            <summary>Tries to compile lambda expression to <typeparamref name="TDelegate"/>.</summary>
            <typeparam name="TDelegate">The compatible delegate type, otherwise case will throw.</typeparam>
            <param name="lambdaExpr">Lambda expression to compile.</param>
            <returns>Compiled delegate.</returns>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.GetParamExprTypes(System.Collections.Generic.IList{System.Linq.Expressions.ParameterExpression})">
            <summary>Performant method to get parameter types from parameter expressions.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCompile``1(System.Linq.Expressions.Expression,System.Collections.Generic.IList{System.Linq.Expressions.ParameterExpression},System.Type[],System.Type)">
            <summary>Compiles expression to delegate by emitting the IL. 
            If sub-expressions are not supported by emitter, then the method returns null.
            The usage should be calling the method, if result is null then calling the Expression.Compile.</summary>
            <param name="bodyExpr">Lambda body.</param>
            <param name="paramExprs">Lambda parameter expressions.</param>
            <param name="paramTypes">The types of parameters.</param>
            <param name="returnType">The return type.</param>
            <returns>Result delegate or null, if unable to compile.</returns>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCompile``1(FastExpressionCompiler.LambdaExpressionInfo)">
            <summary>Tries to compile lambda expression info.</summary>
            <typeparam name="TDelegate">The compatible delegate type, otherwise case will throw.</typeparam>
            <param name="lambdaExpr">Lambda expression to compile.</param>
            <returns>Compiled delegate.</returns>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCompile``1(FastExpressionCompiler.ExpressionInfo{``0})">
            <summary>Tries to compile lambda expression info.</summary>
            <typeparam name="TDelegate">The compatible delegate type, otherwise case will throw.</typeparam>
            <param name="lambdaExpr">Lambda expression to compile.</param>
            <returns>Compiled delegate.</returns>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCompile``1(FastExpressionCompiler.ExpressionInfo,System.Collections.Generic.IList{System.Linq.Expressions.ParameterExpression},System.Type[],System.Type)">
            <summary>Compiles expression to delegate by emitting the IL. 
            If sub-expressions are not supported by emitter, then the method returns null.
            The usage should be calling the method, if result is null then calling the Expression.Compile.</summary>
            <param name="bodyExpr">Lambda body.</param>
            <param name="paramExprs">Lambda parameter expressions.</param>
            <param name="paramTypes">The types of parameters.</param>
            <param name="returnType">The return type.</param>
            <returns>Result delegate or null, if unable to compile.</returns>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.GetFuncOrActionType(System.Type[],System.Type)">
            <summary>Construct delegate type (Func or Action) from given input and return parameter types.</summary>
        </member>
        <member name="T:FastExpressionCompiler.ExpressionCompiler.EmittingVisitor">
            <summary>Supports emitting of selected expressions, e.g. lambdaExpr are not supported yet.
            When emitter find not supported expression it will return false from <see cref="M:FastExpressionCompiler.ExpressionCompiler.EmittingVisitor.TryEmit(System.Object,System.Linq.Expressions.ExpressionType,System.Type,System.Collections.Generic.IList{System.Linq.Expressions.ParameterExpression},System.Reflection.Emit.ILGenerator,FastExpressionCompiler.ExpressionCompiler.ClosureInfo)"/>, so I could fallback
            to normal and slow Expression.Compile.</summary>
        </member>
        <member name="T:FastExpressionCompiler.ExpressionInfo">
            <summary>Facade for constructing expression info.</summary>
        </member>
        <member name="P:FastExpressionCompiler.ExpressionInfo.NodeType">
            <summary>Expression node type.</summary>
        </member>
        <member name="P:FastExpressionCompiler.ExpressionInfo.Type">
            <summary>All expressions should have a Type.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.Constant(System.Object,System.Type)">
            <summary>Analog of Expression.Constant</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.New(System.Reflection.ConstructorInfo)">
            <summary>Analog of Expression.New</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.New(System.Reflection.ConstructorInfo,System.Object[])">
            <summary>Analog of Expression.New</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.New(System.Reflection.ConstructorInfo,FastExpressionCompiler.ExpressionInfo[])">
            <summary>Analog of Expression.New</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.Call(System.Reflection.MethodInfo,System.Object[])">
            <summary>Static method call</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.Call(System.Reflection.MethodInfo,FastExpressionCompiler.ExpressionInfo[])">
            <summary>Static method call</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.Call(FastExpressionCompiler.ExpressionInfo,System.Reflection.MethodInfo,System.Object[])">
            <summary>Instance method call</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.Call(FastExpressionCompiler.ExpressionInfo,System.Reflection.MethodInfo,FastExpressionCompiler.ExpressionInfo[])">
            <summary>Instance method call</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.Property(System.Reflection.PropertyInfo)">
            <summary>Static property</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.Property(FastExpressionCompiler.ExpressionInfo,System.Reflection.PropertyInfo)">
            <summary>Instance property</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.Property(System.Object,System.Reflection.PropertyInfo)">
            <summary>Instance property</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.Field(System.Reflection.FieldInfo)">
            <summary>Static field</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.Property(FastExpressionCompiler.ExpressionInfo,System.Reflection.FieldInfo)">
            <summary>Instance field</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.Lambda(FastExpressionCompiler.ExpressionInfo)">
            <summary>Analog of Expression.Lambda</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.Lambda(FastExpressionCompiler.ExpressionInfo,System.Linq.Expressions.ParameterExpression[])">
            <summary>Analog of Expression.Lambda</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.Lambda(System.Object,System.Linq.Expressions.ParameterExpression[])">
            <summary>Analog of Expression.Lambda</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.Convert(FastExpressionCompiler.ExpressionInfo,System.Type)">
            <summary>Analog of Expression.Convert</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.Lambda``1(FastExpressionCompiler.ExpressionInfo)">
            <summary>Analog of Expression.Lambda</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.Lambda``1(FastExpressionCompiler.ExpressionInfo,System.Linq.Expressions.ParameterExpression[])">
            <summary>Analog of Expression.Lambda</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.ArrayIndex(FastExpressionCompiler.ExpressionInfo,FastExpressionCompiler.ExpressionInfo)">
            <summary>Analog of Expression.ArrayIdex</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.ArrayIndex(System.Object,System.Object)">
            <summary>Analog of Expression.ArrayIdex</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.Bind(System.Reflection.MemberInfo,FastExpressionCompiler.ExpressionInfo)">
            <summary>Expression.Bind used in Expression.MemberInit</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.MemberInit(FastExpressionCompiler.NewExpressionInfo,FastExpressionCompiler.MemberAssignmentInfo[])">
            <summary>Analog of Expression.MemberInit</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.MemberInit(FastExpressionCompiler.ExpressionInfo,FastExpressionCompiler.MemberAssignmentInfo[])">
            <summary>Enables member assignement on existing instance expression.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.NewArrayInit(System.Type,System.Object[])">
            <summary>Constructs an array given the array type and item initializer expressions.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.NewArrayInit(System.Type,FastExpressionCompiler.ExpressionInfo[])">
            <summary>Constructs an array given the array type and item initializer expressions.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.Assign(FastExpressionCompiler.ExpressionInfo,FastExpressionCompiler.ExpressionInfo)">
            <summary>Constructs assignment expression.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.Assign(System.Object,System.Object)">
            <summary>Constructs assignment expression from possibly mixed types of left and right.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo.Invoke(FastExpressionCompiler.LambdaExpressionInfo,System.Object[])">
            <summary>Invoke</summary>
        </member>
        <member name="T:FastExpressionCompiler.UnaryExpressionInfo">
            <summary>Analog of Convert expression.</summary>
        </member>
        <member name="P:FastExpressionCompiler.UnaryExpressionInfo.NodeType">
            <inheritdoc />
        </member>
        <member name="P:FastExpressionCompiler.UnaryExpressionInfo.Type">
            <summary>Target type.</summary>
        </member>
        <member name="F:FastExpressionCompiler.UnaryExpressionInfo.Operand">
            <summary>Operand expression</summary>
        </member>
        <member name="M:FastExpressionCompiler.UnaryExpressionInfo.#ctor(System.Linq.Expressions.ExpressionType,FastExpressionCompiler.ExpressionInfo,System.Type)">
            <summary>Constructor</summary>
        </member>
        <member name="T:FastExpressionCompiler.BinaryExpressionInfo">
            <summary>BinaryExpression analog.</summary>
        </member>
        <member name="P:FastExpressionCompiler.BinaryExpressionInfo.NodeType">
            <inheritdoc />
        </member>
        <member name="P:FastExpressionCompiler.BinaryExpressionInfo.Type">
            <inheritdoc />
        </member>
        <member name="F:FastExpressionCompiler.BinaryExpressionInfo.Left">
            <summary>Left expression</summary>
        </member>
        <member name="F:FastExpressionCompiler.BinaryExpressionInfo.Right">
            <summary>Right expression</summary>
        </member>
        <member name="M:FastExpressionCompiler.BinaryExpressionInfo.#ctor(System.Linq.Expressions.ExpressionType,System.Object,System.Object,System.Type)">
            <summary>Constructs from left and right expressions.</summary>
        </member>
        <member name="T:FastExpressionCompiler.MemberInitExpressionInfo">
            <summary>Analog of MemberInitExpression</summary>
        </member>
        <member name="P:FastExpressionCompiler.MemberInitExpressionInfo.NodeType">
            <inheritdoc />
        </member>
        <member name="P:FastExpressionCompiler.MemberInitExpressionInfo.Type">
            <inheritdoc />
        </member>
        <member name="P:FastExpressionCompiler.MemberInitExpressionInfo.NewExpressionInfo">
            <summary>New expression.</summary>
        </member>
        <member name="F:FastExpressionCompiler.MemberInitExpressionInfo.ExpressionInfo">
            <summary>New expression.</summary>
        </member>
        <member name="F:FastExpressionCompiler.MemberInitExpressionInfo.Bindings">
            <summary>Member assignments.</summary>
        </member>
        <member name="M:FastExpressionCompiler.MemberInitExpressionInfo.#ctor(FastExpressionCompiler.NewExpressionInfo,FastExpressionCompiler.MemberAssignmentInfo[])">
            <summary>Constructs from the new expression and member initialization list.</summary>
        </member>
        <member name="M:FastExpressionCompiler.MemberInitExpressionInfo.#ctor(FastExpressionCompiler.ExpressionInfo,FastExpressionCompiler.MemberAssignmentInfo[])">
            <summary>Constructs from existing expression and member assignment list.</summary>
        </member>
        <member name="T:FastExpressionCompiler.ParameterExpressionInfo">
            <summary>Wraps ParameterExpression and just it.</summary>
        </member>
        <member name="P:FastExpressionCompiler.ParameterExpressionInfo.ParamExpr">
            <summary>Wrapped parameter expression.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ParameterExpressionInfo.op_Implicit(FastExpressionCompiler.ParameterExpressionInfo)~System.Linq.Expressions.ParameterExpression">
            <summary>Allow to change parameter expression as info interchangeable.</summary>
        </member>
        <member name="P:FastExpressionCompiler.ParameterExpressionInfo.NodeType">
            <inheritdoc />
        </member>
        <member name="P:FastExpressionCompiler.ParameterExpressionInfo.Type">
            <inheritdoc />
        </member>
        <member name="P:FastExpressionCompiler.ParameterExpressionInfo.Name">
            <summary>Optional name.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ParameterExpressionInfo.#ctor(System.Linq.Expressions.ParameterExpression)">
            <summary>Constructor</summary>
        </member>
        <member name="T:FastExpressionCompiler.ConstantExpressionInfo">
            <summary>Analog of ConstantExpression.</summary>
        </member>
        <member name="P:FastExpressionCompiler.ConstantExpressionInfo.NodeType">
            <inheritdoc />
        </member>
        <member name="P:FastExpressionCompiler.ConstantExpressionInfo.Type">
            <inheritdoc />
        </member>
        <member name="F:FastExpressionCompiler.ConstantExpressionInfo.Value">
            <summary>Value of constant.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ConstantExpressionInfo.#ctor(System.Object,System.Type)">
            <summary>Constructor</summary>
        </member>
        <member name="T:FastExpressionCompiler.ArgumentsExpressionInfo">
            <summary>Base class for expressions with arguments.</summary>
        </member>
        <member name="F:FastExpressionCompiler.ArgumentsExpressionInfo.Arguments">
            <summary>List of arguments</summary>
        </member>
        <member name="M:FastExpressionCompiler.ArgumentsExpressionInfo.#ctor(System.Object[])">
            <summary>Constructor</summary>
        </member>
        <member name="T:FastExpressionCompiler.NewExpressionInfo">
            <summary>Analog of NewExpression</summary>
        </member>
        <member name="P:FastExpressionCompiler.NewExpressionInfo.NodeType">
            <inheritdoc />
        </member>
        <member name="P:FastExpressionCompiler.NewExpressionInfo.Type">
            <inheritdoc />
        </member>
        <member name="F:FastExpressionCompiler.NewExpressionInfo.Constructor">
            <summary>The constructor info.</summary>
        </member>
        <member name="M:FastExpressionCompiler.NewExpressionInfo.#ctor(System.Reflection.ConstructorInfo,System.Object[])">
            <summary>Construct from constructor info and argument expressions</summary>
        </member>
        <member name="T:FastExpressionCompiler.NewArrayExpressionInfo">
            <summary>NewArrayExpression</summary>
        </member>
        <member name="P:FastExpressionCompiler.NewArrayExpressionInfo.NodeType">
            <inheritdoc />
        </member>
        <member name="P:FastExpressionCompiler.NewArrayExpressionInfo.Type">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.NewArrayExpressionInfo.#ctor(System.Type,System.Object[])">
            <summary>Array type and initializer</summary>
        </member>
        <member name="T:FastExpressionCompiler.MethodCallExpressionInfo">
            <summary>Analog of MethodCallExpression</summary>
        </member>
        <member name="P:FastExpressionCompiler.MethodCallExpressionInfo.NodeType">
            <inheritdoc />
        </member>
        <member name="P:FastExpressionCompiler.MethodCallExpressionInfo.Type">
            <inheritdoc />
        </member>
        <member name="F:FastExpressionCompiler.MethodCallExpressionInfo.Method">
            <summary>The method info.</summary>
        </member>
        <member name="F:FastExpressionCompiler.MethodCallExpressionInfo.Object">
            <summary>Instance expression, null if static.</summary>
        </member>
        <member name="M:FastExpressionCompiler.MethodCallExpressionInfo.#ctor(FastExpressionCompiler.ExpressionInfo,System.Reflection.MethodInfo,System.Object[])">
            <summary>Construct from method info and argument expressions</summary>
        </member>
        <member name="T:FastExpressionCompiler.MemberExpressionInfo">
            <summary>Analog of MemberExpression</summary>
        </member>
        <member name="P:FastExpressionCompiler.MemberExpressionInfo.NodeType">
            <inheritdoc />
        </member>
        <member name="F:FastExpressionCompiler.MemberExpressionInfo.Member">
            <summary>Member info.</summary>
        </member>
        <member name="F:FastExpressionCompiler.MemberExpressionInfo.Expression">
            <summary>Instance expression, null if static.</summary>
        </member>
        <member name="M:FastExpressionCompiler.MemberExpressionInfo.#ctor(System.Object,System.Reflection.MemberInfo)">
            <summary>Constructs with</summary>
        </member>
        <member name="T:FastExpressionCompiler.PropertyExpressionInfo">
            <summary>Analog of PropertyExpression</summary>
        </member>
        <member name="P:FastExpressionCompiler.PropertyExpressionInfo.Type">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.PropertyExpressionInfo.#ctor(System.Object,System.Reflection.PropertyInfo)">
            <summary>Construct from property info</summary>
        </member>
        <member name="T:FastExpressionCompiler.FieldExpressionInfo">
            <summary>Analog of PropertyExpression</summary>
        </member>
        <member name="P:FastExpressionCompiler.FieldExpressionInfo.Type">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.FieldExpressionInfo.#ctor(FastExpressionCompiler.ExpressionInfo,System.Reflection.FieldInfo)">
            <summary>Construct from field info</summary>
        </member>
        <member name="T:FastExpressionCompiler.MemberAssignmentInfo">
            <summary>MemberAssignment analog.</summary>
        </member>
        <member name="F:FastExpressionCompiler.MemberAssignmentInfo.Member">
            <summary>Member to assign to.</summary>
        </member>
        <member name="F:FastExpressionCompiler.MemberAssignmentInfo.Expression">
            <summary>Expression to assign</summary>
        </member>
        <member name="M:FastExpressionCompiler.MemberAssignmentInfo.#ctor(System.Reflection.MemberInfo,FastExpressionCompiler.ExpressionInfo)">
            <summary>Constructs out of member and expression to assign.</summary>
        </member>
        <member name="T:FastExpressionCompiler.LambdaExpressionInfo">
            <summary>LambdaExpression</summary>
        </member>
        <member name="P:FastExpressionCompiler.LambdaExpressionInfo.NodeType">
            <inheritdoc />
        </member>
        <member name="P:FastExpressionCompiler.LambdaExpressionInfo.Type">
            <inheritdoc />
        </member>
        <member name="F:FastExpressionCompiler.LambdaExpressionInfo.Body">
            <summary>Lambda body.</summary>
        </member>
        <member name="F:FastExpressionCompiler.LambdaExpressionInfo.Parameters">
            <summary>List of parameters.</summary>
        </member>
        <member name="M:FastExpressionCompiler.LambdaExpressionInfo.#ctor(System.Object,System.Linq.Expressions.ParameterExpression[])">
            <summary>Constructor</summary>
        </member>
        <member name="T:FastExpressionCompiler.ExpressionInfo`1">
            <summary>Typed lambda expression.</summary>
        </member>
        <member name="P:FastExpressionCompiler.ExpressionInfo`1.DelegateType">
            <summary>Type of lambda</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionInfo`1.#ctor(FastExpressionCompiler.ExpressionInfo,System.Linq.Expressions.ParameterExpression[])">
            <summary>Constructor</summary>
        </member>
        <member name="T:FastExpressionCompiler.InvocationExpressionInfo">
            <summary>Analog of InvocationExpression.</summary>
        </member>
        <member name="P:FastExpressionCompiler.InvocationExpressionInfo.NodeType">
            <inheritdoc />
        </member>
        <member name="P:FastExpressionCompiler.InvocationExpressionInfo.Type">
            <inheritdoc />
        </member>
        <member name="F:FastExpressionCompiler.InvocationExpressionInfo.LambdaExprInfo">
            <summary>Delegate to invoke.</summary>
        </member>
        <member name="M:FastExpressionCompiler.InvocationExpressionInfo.#ctor(FastExpressionCompiler.LambdaExpressionInfo,System.Object[],System.Type)">
            <summary>Constructs</summary>
        </member>
    </members>
</doc>
